# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE telegramId = $1',
            4528818900,
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'telegramId': 7953889008,
                'referralCode': 'bbehjachib',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'telegramId': 24420185688,
                    'referralCode': 'dgiiaaijj',
                },
                {
                    # data to create a User record
                    'telegramId': 18096359424,
                    'referralCode': 'eigcfgbif',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'bagcfbhiig',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'cghideieh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'biabhbdai',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the username field
        users = await User.prisma().find_many(
            take=5,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the firstName field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'firstName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the lastName field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'lastName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'idghgaicb',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'fjfddhigg',
            },
            data={
                'create': {
                    'id': 'fjfddhigg',
                    'telegramId': 18096359424,
                    'referralCode': 'eigcfgbif',
                },
                'update': {
                    'telegramId': 18096359424,
                    'referralCode': 'eigcfgbif',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'email': 'hjaecfifb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'whatsapp': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'latitude': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by longitude values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['longitude'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class BalanceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Balance]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Balance.prisma().query_raw(
            'SELECT * FROM Balance WHERE id = $1',
            'cbbbjbfcii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Balance
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Balance.prisma().query_first(
            'SELECT * FROM Balance WHERE userId = $1',
            'bbejhfidcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.BalanceCreateInput,
        include: Optional[types.BalanceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Balance record.

        Parameters
        ----------
        data
            Balance record data
        include
            Specifies which relations should be loaded on the returned Balance model

        Returns
        -------
        prisma.models.Balance
            The created Balance record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Balance record from just the required fields
        balance = await Balance.prisma().create(
            data={
                # data to create a Balance record
                'userId': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.BalanceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Balance records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Balance record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Balance.prisma().create_many(
            data=[
                {
                    # data to create a Balance record
                    'userId': 'bdiicjafbj',
                },
                {
                    # data to create a Balance record
                    'userId': 'bgehebiafc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.BalanceWhereUniqueInput,
        include: Optional[types.BalanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Balance record.

        Parameters
        ----------
        where
            Balance filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Balance model

        Returns
        -------
        prisma.models.Balance
            The deleted Balance record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        balance = await Balance.prisma().delete(
            where={
                'id': 'bghffegacj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.BalanceWhereUniqueInput,
        include: Optional[types.BalanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Balance record.

        Parameters
        ----------
        where
            Balance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Balance model

        Returns
        -------
        prisma.models.Balance
            The found Balance record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        balance = await Balance.prisma().find_unique(
            where={
                'id': 'bhghchehcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.BalanceWhereUniqueInput,
        include: Optional[types.BalanceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Balance record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Balance filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Balance model

        Returns
        -------
        prisma.models.Balance
            The found Balance record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        balance = await Balance.prisma().find_unique_or_raise(
            where={
                'id': 'dcgchcbbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BalanceWhereInput] = None,
        cursor: Optional[types.BalanceWhereUniqueInput] = None,
        include: Optional[types.BalanceInclude] = None,
        order: Optional[Union[types.BalanceOrderByInput, List[types.BalanceOrderByInput]]] = None,
        distinct: Optional[List[types.BalanceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Balance records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Balance records returned
        skip
            Ignore the first N results
        where
            Balance filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Balance model
        order
            Order the returned Balance records by any field
        distinct
            Filter Balance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Balance]
            The list of all Balance records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Balance records
        balances = await Balance.prisma().find_many(take=10)

        # find the first 5 Balance records ordered by the amount field
        balances = await Balance.prisma().find_many(
            take=5,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BalanceWhereInput] = None,
        cursor: Optional[types.BalanceWhereUniqueInput] = None,
        include: Optional[types.BalanceInclude] = None,
        order: Optional[Union[types.BalanceOrderByInput, List[types.BalanceOrderByInput]]] = None,
        distinct: Optional[List[types.BalanceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Balance record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Balance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Balance model
        order
            Order the returned Balance records by any field
        distinct
            Filter Balance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Balance
            The first Balance record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Balance record ordered by the createdAt field
        balance = await Balance.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.BalanceWhereInput] = None,
        cursor: Optional[types.BalanceWhereUniqueInput] = None,
        include: Optional[types.BalanceInclude] = None,
        order: Optional[Union[types.BalanceOrderByInput, List[types.BalanceOrderByInput]]] = None,
        distinct: Optional[List[types.BalanceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Balance record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Balance filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Balance model
        order
            Order the returned Balance records by any field
        distinct
            Filter Balance records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Balance
            The first Balance record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Balance record ordered by the updatedAt field
        balance = await Balance.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.BalanceUpdateInput,
        where: types.BalanceWhereUniqueInput,
        include: Optional[types.BalanceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Balance record.

        Parameters
        ----------
        data
            Balance record data specifying what to update
        where
            Balance filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Balance model

        Returns
        -------
        prisma.models.Balance
            The updated Balance record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        balance = await Balance.prisma().update(
            where={
                'id': 'bdedcabahc',
            },
            data={
                # data to update the Balance record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.BalanceWhereUniqueInput,
        data: types.BalanceUpsertInput,
        include: Optional[types.BalanceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Balance filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Balance model

        Returns
        -------
        prisma.models.Balance
            The created or updated Balance record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        balance = await Balance.prisma().upsert(
            where={
                'id': 'ghfhiafcb',
            },
            data={
                'create': {
                    'id': 'ghfhiafcb',
                    'userId': 'bgehebiafc',
                },
                'update': {
                    'userId': 'bgehebiafc',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.BalanceUpdateManyMutationInput,
        where: types.BalanceWhereInput,
    ) -> int:
        """Update multiple Balance records

        Parameters
        ----------
        data
            Balance data to update the selected Balance records to
        where
            Filter to select the Balance records to update

        Returns
        -------
        int
            The total number of Balance records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Balance records
        total = await Balance.prisma().update_many(
            data={
                'id': 'heejgedji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BalanceWhereInput] = None,
        cursor: Optional[types.BalanceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Balance records present in the database

        Parameters
        ----------
        select
            Select the Balance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Balance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BalanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Balance.prisma().count()

        # results: prisma.types.BalanceCountAggregateOutput
        results = await Balance.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.BalanceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BalanceWhereInput] = None,
        cursor: Optional[types.BalanceWhereUniqueInput] = None,
    ) -> types.BalanceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.BalanceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.BalanceWhereInput] = None,
        cursor: Optional[types.BalanceWhereUniqueInput] = None,
    ) -> Union[int, types.BalanceCountAggregateOutput]:
        """Count the number of Balance records present in the database

        Parameters
        ----------
        select
            Select the Balance fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Balance filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.BalanceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Balance.prisma().count()

        # results: prisma.types.BalanceCountAggregateOutput
        results = await Balance.prisma().count(
            select={
                '_all': True,
                'amount': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.BalanceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.BalanceWhereInput] = None
    ) -> int:
        """Delete multiple Balance records.

        Parameters
        ----------
        where
            Optional Balance filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Balance records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Balance records
        total = await Balance.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.BalanceScalarFieldKeys'],
        *,
        where: Optional['types.BalanceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.BalanceAvgAggregateInput'] = None,
        sum: Optional['types.BalanceSumAggregateInput'] = None,
        min: Optional['types.BalanceMinAggregateInput'] = None,
        max: Optional['types.BalanceMaxAggregateInput'] = None,
        having: Optional['types.BalanceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.BalanceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.BalanceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.BalanceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.BalanceGroupByOutput']:
        """Group Balance records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Balance fields to group records by
        where
            Balance filter to select records
        take
            Limit the maximum number of Balance records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.BalanceGroupByOutput]
            A list of dictionaries representing the Balance record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Balance records by createdAt values
        # and count how many records are in each group
        results = await Balance.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class TransactionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Transaction]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Transaction.prisma().query_raw(
            'SELECT * FROM Transaction WHERE id = $1',
            'bjgjgibgbf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Transaction
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Transaction.prisma().query_first(
            'SELECT * FROM Transaction WHERE userId = $1',
            'bbbgbhfjge',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.TransactionCreateInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Transaction record.

        Parameters
        ----------
        data
            Transaction record data
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created Transaction record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Transaction record from just the required fields
        transaction = await Transaction.prisma().create(
            data={
                # data to create a Transaction record
                'userId': 'igbehcbab',
                'type': enums.TransactionType.BUY,
                'amount': Decimal('1303003706.168663'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.TransactionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Transaction records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Transaction record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Transaction.prisma().create_many(
            data=[
                {
                    # data to create a Transaction record
                    'userId': 'caaaedabfc',
                    'type': enums.TransactionType.BUY,
                    'amount': Decimal('1868141281.186084'),
                },
                {
                    # data to create a Transaction record
                    'userId': 'beeifcbebf',
                    'type': enums.TransactionType.BUY,
                    'amount': Decimal('1628650740.124960'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Transaction record.

        Parameters
        ----------
        where
            Transaction filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The deleted Transaction record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().delete(
            where={
                'id': 'idfjadbcc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Transaction record.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique(
            where={
                'id': 'hgdhbjhhj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Transaction record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Transaction filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The found Transaction record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().find_unique_or_raise(
            where={
                'id': 'ecjjjfbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Transaction records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N results
        where
            Transaction filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Transaction]
            The list of all Transaction records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Transaction records
        transactions = await Transaction.prisma().find_many(take=10)

        # find the first 5 Transaction records ordered by the type field
        transactions = await Transaction.prisma().find_many(
            take=5,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Transaction record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the amount field
        transaction = await Transaction.prisma().find_first(
            skip=1,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
        include: Optional[types.TransactionInclude] = None,
        order: Optional[Union[types.TransactionOrderByInput, List[types.TransactionOrderByInput]]] = None,
        distinct: Optional[List[types.TransactionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Transaction record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Transaction filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Transaction model
        order
            Order the returned Transaction records by any field
        distinct
            Filter Transaction records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Transaction
            The first Transaction record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Transaction record ordered by the description field
        transaction = await Transaction.prisma().find_first_or_raise(
            skip=1,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.TransactionUpdateInput,
        where: types.TransactionWhereUniqueInput,
        include: Optional[types.TransactionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Transaction record.

        Parameters
        ----------
        data
            Transaction record data specifying what to update
        where
            Transaction filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The updated Transaction record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        transaction = await Transaction.prisma().update(
            where={
                'id': 'bhhfibbigf',
            },
            data={
                # data to update the Transaction record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.TransactionWhereUniqueInput,
        data: types.TransactionUpsertInput,
        include: Optional[types.TransactionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Transaction filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Transaction model

        Returns
        -------
        prisma.models.Transaction
            The created or updated Transaction record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        transaction = await Transaction.prisma().upsert(
            where={
                'id': 'ijdbeffgg',
            },
            data={
                'create': {
                    'id': 'ijdbeffgg',
                    'userId': 'beeifcbebf',
                    'type': enums.TransactionType.BUY,
                    'amount': Decimal('1628650740.124960'),
                },
                'update': {
                    'userId': 'beeifcbebf',
                    'type': enums.TransactionType.BUY,
                    'amount': Decimal('1628650740.124960'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.TransactionUpdateManyMutationInput,
        where: types.TransactionWhereInput,
    ) -> int:
        """Update multiple Transaction records

        Parameters
        ----------
        data
            Transaction data to update the selected Transaction records to
        where
            Filter to select the Transaction records to update

        Returns
        -------
        int
            The total number of Transaction records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Transaction records
        total = await Transaction.prisma().update_many(
            data={
                'status': enums.TransactionStatus.PENDING
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'metadata': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.TransactionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> types.TransactionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.TransactionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.TransactionWhereInput] = None,
        cursor: Optional[types.TransactionWhereUniqueInput] = None,
    ) -> Union[int, types.TransactionCountAggregateOutput]:
        """Count the number of Transaction records present in the database

        Parameters
        ----------
        select
            Select the Transaction fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Transaction filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.TransactionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Transaction.prisma().count()

        # results: prisma.types.TransactionCountAggregateOutput
        results = await Transaction.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.TransactionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.TransactionWhereInput] = None
    ) -> int:
        """Delete multiple Transaction records.

        Parameters
        ----------
        where
            Optional Transaction filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Transaction records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Transaction records
        total = await Transaction.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.TransactionScalarFieldKeys'],
        *,
        where: Optional['types.TransactionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.TransactionAvgAggregateInput'] = None,
        sum: Optional['types.TransactionSumAggregateInput'] = None,
        min: Optional['types.TransactionMinAggregateInput'] = None,
        max: Optional['types.TransactionMaxAggregateInput'] = None,
        having: Optional['types.TransactionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.TransactionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.TransactionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.TransactionGroupByOutput']:
        """Group Transaction records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Transaction fields to group records by
        where
            Transaction filter to select records
        take
            Limit the maximum number of Transaction records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.TransactionGroupByOutput]
            A list of dictionaries representing the Transaction record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Transaction records by updatedAt values
        # and count how many records are in each group
        results = await Transaction.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DepositActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Deposit]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Deposit.prisma().query_raw(
            'SELECT * FROM Deposit WHERE id = $1',
            'jjfeafhfj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Deposit
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Deposit.prisma().query_first(
            'SELECT * FROM Deposit WHERE userId = $1',
            'cbachdgfce',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DepositCreateInput,
        include: Optional[types.DepositInclude] = None
    ) -> _PrismaModelT:
        """Create a new Deposit record.

        Parameters
        ----------
        data
            Deposit record data
        include
            Specifies which relations should be loaded on the returned Deposit model

        Returns
        -------
        prisma.models.Deposit
            The created Deposit record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Deposit record from just the required fields
        deposit = await Deposit.prisma().create(
            data={
                # data to create a Deposit record
                'userId': 'chbfcacbd',
                'amount': Decimal('456633834.205825'),
                'paymentMethod': 'bfidgijfjc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DepositCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Deposit records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Deposit record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Deposit.prisma().create_many(
            data=[
                {
                    # data to create a Deposit record
                    'userId': 'ihieecagf',
                    'amount': Decimal('1675280054.162757'),
                    'paymentMethod': 'cafeiaccbc',
                },
                {
                    # data to create a Deposit record
                    'userId': 'gaddfhfh',
                    'amount': Decimal('684462146.162550'),
                    'paymentMethod': 'fcbichhci',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DepositWhereUniqueInput,
        include: Optional[types.DepositInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Deposit record.

        Parameters
        ----------
        where
            Deposit filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Deposit model

        Returns
        -------
        prisma.models.Deposit
            The deleted Deposit record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        deposit = await Deposit.prisma().delete(
            where={
                'id': 'bcggadccgf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DepositWhereUniqueInput,
        include: Optional[types.DepositInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Deposit record.

        Parameters
        ----------
        where
            Deposit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Deposit model

        Returns
        -------
        prisma.models.Deposit
            The found Deposit record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        deposit = await Deposit.prisma().find_unique(
            where={
                'id': 'jdcfdcgc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DepositWhereUniqueInput,
        include: Optional[types.DepositInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Deposit record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Deposit filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Deposit model

        Returns
        -------
        prisma.models.Deposit
            The found Deposit record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        deposit = await Deposit.prisma().find_unique_or_raise(
            where={
                'id': 'cafdaehjid',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepositWhereInput] = None,
        cursor: Optional[types.DepositWhereUniqueInput] = None,
        include: Optional[types.DepositInclude] = None,
        order: Optional[Union[types.DepositOrderByInput, List[types.DepositOrderByInput]]] = None,
        distinct: Optional[List[types.DepositScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Deposit records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Deposit records returned
        skip
            Ignore the first N results
        where
            Deposit filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Deposit model
        order
            Order the returned Deposit records by any field
        distinct
            Filter Deposit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Deposit]
            The list of all Deposit records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Deposit records
        deposits = await Deposit.prisma().find_many(take=10)

        # find the first 5 Deposit records ordered by the amount field
        deposits = await Deposit.prisma().find_many(
            take=5,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepositWhereInput] = None,
        cursor: Optional[types.DepositWhereUniqueInput] = None,
        include: Optional[types.DepositInclude] = None,
        order: Optional[Union[types.DepositOrderByInput, List[types.DepositOrderByInput]]] = None,
        distinct: Optional[List[types.DepositScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Deposit record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Deposit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Deposit model
        order
            Order the returned Deposit records by any field
        distinct
            Filter Deposit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Deposit
            The first Deposit record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Deposit record ordered by the paymentMethod field
        deposit = await Deposit.prisma().find_first(
            skip=1,
            order={
                'paymentMethod': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepositWhereInput] = None,
        cursor: Optional[types.DepositWhereUniqueInput] = None,
        include: Optional[types.DepositInclude] = None,
        order: Optional[Union[types.DepositOrderByInput, List[types.DepositOrderByInput]]] = None,
        distinct: Optional[List[types.DepositScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Deposit record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Deposit filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Deposit model
        order
            Order the returned Deposit records by any field
        distinct
            Filter Deposit records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Deposit
            The first Deposit record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Deposit record ordered by the proofImage field
        deposit = await Deposit.prisma().find_first_or_raise(
            skip=1,
            order={
                'proofImage': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DepositUpdateInput,
        where: types.DepositWhereUniqueInput,
        include: Optional[types.DepositInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Deposit record.

        Parameters
        ----------
        data
            Deposit record data specifying what to update
        where
            Deposit filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Deposit model

        Returns
        -------
        prisma.models.Deposit
            The updated Deposit record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        deposit = await Deposit.prisma().update(
            where={
                'id': 'gifdddbia',
            },
            data={
                # data to update the Deposit record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DepositWhereUniqueInput,
        data: types.DepositUpsertInput,
        include: Optional[types.DepositInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Deposit filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Deposit model

        Returns
        -------
        prisma.models.Deposit
            The created or updated Deposit record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        deposit = await Deposit.prisma().upsert(
            where={
                'id': 'bchehecef',
            },
            data={
                'create': {
                    'id': 'bchehecef',
                    'userId': 'gaddfhfh',
                    'amount': Decimal('684462146.162550'),
                    'paymentMethod': 'fcbichhci',
                },
                'update': {
                    'userId': 'gaddfhfh',
                    'amount': Decimal('684462146.162550'),
                    'paymentMethod': 'fcbichhci',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DepositUpdateManyMutationInput,
        where: types.DepositWhereInput,
    ) -> int:
        """Update multiple Deposit records

        Parameters
        ----------
        data
            Deposit data to update the selected Deposit records to
        where
            Filter to select the Deposit records to update

        Returns
        -------
        int
            The total number of Deposit records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Deposit records
        total = await Deposit.prisma().update_many(
            data={
                'cryptobotInvoiceId': 'jeijcbhfe'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepositWhereInput] = None,
        cursor: Optional[types.DepositWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Deposit records present in the database

        Parameters
        ----------
        select
            Select the Deposit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Deposit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepositCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Deposit.prisma().count()

        # results: prisma.types.DepositCountAggregateOutput
        results = await Deposit.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DepositCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepositWhereInput] = None,
        cursor: Optional[types.DepositWhereUniqueInput] = None,
    ) -> types.DepositCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DepositCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepositWhereInput] = None,
        cursor: Optional[types.DepositWhereUniqueInput] = None,
    ) -> Union[int, types.DepositCountAggregateOutput]:
        """Count the number of Deposit records present in the database

        Parameters
        ----------
        select
            Select the Deposit fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Deposit filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepositCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Deposit.prisma().count()

        # results: prisma.types.DepositCountAggregateOutput
        results = await Deposit.prisma().count(
            select={
                '_all': True,
                'adminNote': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DepositCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DepositWhereInput] = None
    ) -> int:
        """Delete multiple Deposit records.

        Parameters
        ----------
        where
            Optional Deposit filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Deposit records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Deposit records
        total = await Deposit.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DepositScalarFieldKeys'],
        *,
        where: Optional['types.DepositWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DepositAvgAggregateInput'] = None,
        sum: Optional['types.DepositSumAggregateInput'] = None,
        min: Optional['types.DepositMinAggregateInput'] = None,
        max: Optional['types.DepositMaxAggregateInput'] = None,
        having: Optional['types.DepositScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DepositCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DepositScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DepositScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DepositGroupByOutput']:
        """Group Deposit records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Deposit fields to group records by
        where
            Deposit filter to select records
        take
            Limit the maximum number of Deposit records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DepositGroupByOutput]
            A list of dictionaries representing the Deposit record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Deposit records by approvedById values
        # and count how many records are in each group
        results = await Deposit.prisma().group_by(
            ['approvedById'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WithdrawalActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Withdrawal]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Withdrawal.prisma().query_raw(
            'SELECT * FROM Withdrawal WHERE id = $1',
            'bjgejjabff',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Withdrawal
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Withdrawal.prisma().query_first(
            'SELECT * FROM Withdrawal WHERE userId = $1',
            'bcciijbibg',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WithdrawalCreateInput,
        include: Optional[types.WithdrawalInclude] = None
    ) -> _PrismaModelT:
        """Create a new Withdrawal record.

        Parameters
        ----------
        data
            Withdrawal record data
        include
            Specifies which relations should be loaded on the returned Withdrawal model

        Returns
        -------
        prisma.models.Withdrawal
            The created Withdrawal record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Withdrawal record from just the required fields
        withdrawal = await Withdrawal.prisma().create(
            data={
                # data to create a Withdrawal record
                'userId': 'cffcachfd',
                'amount': Decimal('1223573862.54126'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WithdrawalCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Withdrawal records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Withdrawal record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Withdrawal.prisma().create_many(
            data=[
                {
                    # data to create a Withdrawal record
                    'userId': 'bageiegghg',
                    'amount': Decimal('508382461.102426'),
                },
                {
                    # data to create a Withdrawal record
                    'userId': 'ihcahiead',
                    'amount': Decimal('1874748096.91689'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WithdrawalWhereUniqueInput,
        include: Optional[types.WithdrawalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Withdrawal record.

        Parameters
        ----------
        where
            Withdrawal filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Withdrawal model

        Returns
        -------
        prisma.models.Withdrawal
            The deleted Withdrawal record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        withdrawal = await Withdrawal.prisma().delete(
            where={
                'id': 'hgjcghfbi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WithdrawalWhereUniqueInput,
        include: Optional[types.WithdrawalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Withdrawal record.

        Parameters
        ----------
        where
            Withdrawal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Withdrawal model

        Returns
        -------
        prisma.models.Withdrawal
            The found Withdrawal record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        withdrawal = await Withdrawal.prisma().find_unique(
            where={
                'id': 'icadbcehj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WithdrawalWhereUniqueInput,
        include: Optional[types.WithdrawalInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Withdrawal record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Withdrawal filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Withdrawal model

        Returns
        -------
        prisma.models.Withdrawal
            The found Withdrawal record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        withdrawal = await Withdrawal.prisma().find_unique_or_raise(
            where={
                'id': 'jchciaee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WithdrawalWhereInput] = None,
        cursor: Optional[types.WithdrawalWhereUniqueInput] = None,
        include: Optional[types.WithdrawalInclude] = None,
        order: Optional[Union[types.WithdrawalOrderByInput, List[types.WithdrawalOrderByInput]]] = None,
        distinct: Optional[List[types.WithdrawalScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Withdrawal records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Withdrawal records returned
        skip
            Ignore the first N results
        where
            Withdrawal filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Withdrawal model
        order
            Order the returned Withdrawal records by any field
        distinct
            Filter Withdrawal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Withdrawal]
            The list of all Withdrawal records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Withdrawal records
        withdrawals = await Withdrawal.prisma().find_many(take=10)

        # find the first 5 Withdrawal records ordered by the amount field
        withdrawals = await Withdrawal.prisma().find_many(
            take=5,
            order={
                'amount': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WithdrawalWhereInput] = None,
        cursor: Optional[types.WithdrawalWhereUniqueInput] = None,
        include: Optional[types.WithdrawalInclude] = None,
        order: Optional[Union[types.WithdrawalOrderByInput, List[types.WithdrawalOrderByInput]]] = None,
        distinct: Optional[List[types.WithdrawalScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Withdrawal record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Withdrawal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Withdrawal model
        order
            Order the returned Withdrawal records by any field
        distinct
            Filter Withdrawal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Withdrawal
            The first Withdrawal record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Withdrawal record ordered by the bankName field
        withdrawal = await Withdrawal.prisma().find_first(
            skip=1,
            order={
                'bankName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WithdrawalWhereInput] = None,
        cursor: Optional[types.WithdrawalWhereUniqueInput] = None,
        include: Optional[types.WithdrawalInclude] = None,
        order: Optional[Union[types.WithdrawalOrderByInput, List[types.WithdrawalOrderByInput]]] = None,
        distinct: Optional[List[types.WithdrawalScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Withdrawal record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Withdrawal filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Withdrawal model
        order
            Order the returned Withdrawal records by any field
        distinct
            Filter Withdrawal records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Withdrawal
            The first Withdrawal record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Withdrawal record ordered by the accountNumber field
        withdrawal = await Withdrawal.prisma().find_first_or_raise(
            skip=1,
            order={
                'accountNumber': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WithdrawalUpdateInput,
        where: types.WithdrawalWhereUniqueInput,
        include: Optional[types.WithdrawalInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Withdrawal record.

        Parameters
        ----------
        data
            Withdrawal record data specifying what to update
        where
            Withdrawal filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Withdrawal model

        Returns
        -------
        prisma.models.Withdrawal
            The updated Withdrawal record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        withdrawal = await Withdrawal.prisma().update(
            where={
                'id': 'deeificjd',
            },
            data={
                # data to update the Withdrawal record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WithdrawalWhereUniqueInput,
        data: types.WithdrawalUpsertInput,
        include: Optional[types.WithdrawalInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Withdrawal filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Withdrawal model

        Returns
        -------
        prisma.models.Withdrawal
            The created or updated Withdrawal record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        withdrawal = await Withdrawal.prisma().upsert(
            where={
                'id': 'bbcbhebbda',
            },
            data={
                'create': {
                    'id': 'bbcbhebbda',
                    'userId': 'ihcahiead',
                    'amount': Decimal('1874748096.91689'),
                },
                'update': {
                    'userId': 'ihcahiead',
                    'amount': Decimal('1874748096.91689'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WithdrawalUpdateManyMutationInput,
        where: types.WithdrawalWhereInput,
    ) -> int:
        """Update multiple Withdrawal records

        Parameters
        ----------
        data
            Withdrawal data to update the selected Withdrawal records to
        where
            Filter to select the Withdrawal records to update

        Returns
        -------
        int
            The total number of Withdrawal records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Withdrawal records
        total = await Withdrawal.prisma().update_many(
            data={
                'accountName': 'bejfijgcfb'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WithdrawalWhereInput] = None,
        cursor: Optional[types.WithdrawalWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Withdrawal records present in the database

        Parameters
        ----------
        select
            Select the Withdrawal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Withdrawal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WithdrawalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Withdrawal.prisma().count()

        # results: prisma.types.WithdrawalCountAggregateOutput
        results = await Withdrawal.prisma().count(
            select={
                '_all': True,
                'ewalletType': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WithdrawalCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WithdrawalWhereInput] = None,
        cursor: Optional[types.WithdrawalWhereUniqueInput] = None,
    ) -> types.WithdrawalCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WithdrawalCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WithdrawalWhereInput] = None,
        cursor: Optional[types.WithdrawalWhereUniqueInput] = None,
    ) -> Union[int, types.WithdrawalCountAggregateOutput]:
        """Count the number of Withdrawal records present in the database

        Parameters
        ----------
        select
            Select the Withdrawal fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Withdrawal filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WithdrawalCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Withdrawal.prisma().count()

        # results: prisma.types.WithdrawalCountAggregateOutput
        results = await Withdrawal.prisma().count(
            select={
                '_all': True,
                'ewalletNumber': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WithdrawalCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WithdrawalWhereInput] = None
    ) -> int:
        """Delete multiple Withdrawal records.

        Parameters
        ----------
        where
            Optional Withdrawal filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Withdrawal records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Withdrawal records
        total = await Withdrawal.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WithdrawalScalarFieldKeys'],
        *,
        where: Optional['types.WithdrawalWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WithdrawalAvgAggregateInput'] = None,
        sum: Optional['types.WithdrawalSumAggregateInput'] = None,
        min: Optional['types.WithdrawalMinAggregateInput'] = None,
        max: Optional['types.WithdrawalMaxAggregateInput'] = None,
        having: Optional['types.WithdrawalScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WithdrawalCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WithdrawalScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WithdrawalScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WithdrawalGroupByOutput']:
        """Group Withdrawal records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Withdrawal fields to group records by
        where
            Withdrawal filter to select records
        take
            Limit the maximum number of Withdrawal records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WithdrawalGroupByOutput]
            A list of dictionaries representing the Withdrawal record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Withdrawal records by status values
        # and count how many records are in each group
        results = await Withdrawal.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CryptoOrderActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CryptoOrder]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CryptoOrder.prisma().query_raw(
            'SELECT * FROM CryptoOrder WHERE id = $1',
            'caifcbgii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CryptoOrder
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CryptoOrder.prisma().query_first(
            'SELECT * FROM CryptoOrder WHERE userId = $1',
            'igaibbfgj',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CryptoOrderCreateInput,
        include: Optional[types.CryptoOrderInclude] = None
    ) -> _PrismaModelT:
        """Create a new CryptoOrder record.

        Parameters
        ----------
        data
            CryptoOrder record data
        include
            Specifies which relations should be loaded on the returned CryptoOrder model

        Returns
        -------
        prisma.models.CryptoOrder
            The created CryptoOrder record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CryptoOrder record from just the required fields
        cryptoorder = await CryptoOrder.prisma().create(
            data={
                # data to create a CryptoOrder record
                'userId': 'bggajdcbbi',
                'orderType': enums.OrderType.BUY,
                'coinSymbol': 'fcfhgbjed',
                'network': 'hdgcajhjg',
                'cryptoAmount': Decimal('493907821.63968'),
                'fiatAmount': Decimal('654007347.190526'),
                'rate': Decimal('78746985.139832'),
                'margin': Decimal('856000655.145233'),
                'networkFee': Decimal('1573199653.201390'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CryptoOrderCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CryptoOrder records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CryptoOrder record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CryptoOrder.prisma().create_many(
            data=[
                {
                    # data to create a CryptoOrder record
                    'userId': 'faajgfadf',
                    'orderType': enums.OrderType.BUY,
                    'coinSymbol': 'biaagcedjc',
                    'network': 'cahhaghecf',
                    'cryptoAmount': Decimal('1672112838.92667'),
                    'fiatAmount': Decimal('1447624116.173808'),
                    'rate': Decimal('340946258.60107'),
                    'margin': Decimal('290603296.185582'),
                    'networkFee': Decimal('1611009182.44667'),
                },
                {
                    # data to create a CryptoOrder record
                    'userId': 'daafgidjg',
                    'orderType': enums.OrderType.BUY,
                    'coinSymbol': 'gdcgcgagj',
                    'network': 'bhceabbgja',
                    'cryptoAmount': Decimal('470157467.120920'),
                    'fiatAmount': Decimal('1536744465.42421'),
                    'rate': Decimal('2125632375.53695'),
                    'margin': Decimal('924723277.162193'),
                    'networkFee': Decimal('1848832019.192152'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CryptoOrderWhereUniqueInput,
        include: Optional[types.CryptoOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CryptoOrder record.

        Parameters
        ----------
        where
            CryptoOrder filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CryptoOrder model

        Returns
        -------
        prisma.models.CryptoOrder
            The deleted CryptoOrder record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cryptoorder = await CryptoOrder.prisma().delete(
            where={
                'id': 'cbaaechiej',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CryptoOrderWhereUniqueInput,
        include: Optional[types.CryptoOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CryptoOrder record.

        Parameters
        ----------
        where
            CryptoOrder filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CryptoOrder model

        Returns
        -------
        prisma.models.CryptoOrder
            The found CryptoOrder record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cryptoorder = await CryptoOrder.prisma().find_unique(
            where={
                'id': 'iejbeaaeg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CryptoOrderWhereUniqueInput,
        include: Optional[types.CryptoOrderInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CryptoOrder record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CryptoOrder filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CryptoOrder model

        Returns
        -------
        prisma.models.CryptoOrder
            The found CryptoOrder record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cryptoorder = await CryptoOrder.prisma().find_unique_or_raise(
            where={
                'id': 'jcibfcbhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CryptoOrderWhereInput] = None,
        cursor: Optional[types.CryptoOrderWhereUniqueInput] = None,
        include: Optional[types.CryptoOrderInclude] = None,
        order: Optional[Union[types.CryptoOrderOrderByInput, List[types.CryptoOrderOrderByInput]]] = None,
        distinct: Optional[List[types.CryptoOrderScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CryptoOrder records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CryptoOrder records returned
        skip
            Ignore the first N results
        where
            CryptoOrder filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CryptoOrder model
        order
            Order the returned CryptoOrder records by any field
        distinct
            Filter CryptoOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CryptoOrder]
            The list of all CryptoOrder records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CryptoOrder records
        cryptoorders = await CryptoOrder.prisma().find_many(take=10)

        # find the first 5 CryptoOrder records ordered by the orderType field
        cryptoorders = await CryptoOrder.prisma().find_many(
            take=5,
            order={
                'orderType': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CryptoOrderWhereInput] = None,
        cursor: Optional[types.CryptoOrderWhereUniqueInput] = None,
        include: Optional[types.CryptoOrderInclude] = None,
        order: Optional[Union[types.CryptoOrderOrderByInput, List[types.CryptoOrderOrderByInput]]] = None,
        distinct: Optional[List[types.CryptoOrderScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CryptoOrder record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CryptoOrder filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CryptoOrder model
        order
            Order the returned CryptoOrder records by any field
        distinct
            Filter CryptoOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CryptoOrder
            The first CryptoOrder record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CryptoOrder record ordered by the coinSymbol field
        cryptoorder = await CryptoOrder.prisma().find_first(
            skip=1,
            order={
                'coinSymbol': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CryptoOrderWhereInput] = None,
        cursor: Optional[types.CryptoOrderWhereUniqueInput] = None,
        include: Optional[types.CryptoOrderInclude] = None,
        order: Optional[Union[types.CryptoOrderOrderByInput, List[types.CryptoOrderOrderByInput]]] = None,
        distinct: Optional[List[types.CryptoOrderScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CryptoOrder record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CryptoOrder filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CryptoOrder model
        order
            Order the returned CryptoOrder records by any field
        distinct
            Filter CryptoOrder records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CryptoOrder
            The first CryptoOrder record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CryptoOrder record ordered by the network field
        cryptoorder = await CryptoOrder.prisma().find_first_or_raise(
            skip=1,
            order={
                'network': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CryptoOrderUpdateInput,
        where: types.CryptoOrderWhereUniqueInput,
        include: Optional[types.CryptoOrderInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CryptoOrder record.

        Parameters
        ----------
        data
            CryptoOrder record data specifying what to update
        where
            CryptoOrder filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CryptoOrder model

        Returns
        -------
        prisma.models.CryptoOrder
            The updated CryptoOrder record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cryptoorder = await CryptoOrder.prisma().update(
            where={
                'id': 'chdadcaga',
            },
            data={
                # data to update the CryptoOrder record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CryptoOrderWhereUniqueInput,
        data: types.CryptoOrderUpsertInput,
        include: Optional[types.CryptoOrderInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CryptoOrder filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CryptoOrder model

        Returns
        -------
        prisma.models.CryptoOrder
            The created or updated CryptoOrder record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cryptoorder = await CryptoOrder.prisma().upsert(
            where={
                'id': 'jicieifbh',
            },
            data={
                'create': {
                    'id': 'jicieifbh',
                    'userId': 'daafgidjg',
                    'orderType': enums.OrderType.BUY,
                    'coinSymbol': 'gdcgcgagj',
                    'network': 'bhceabbgja',
                    'cryptoAmount': Decimal('470157467.120920'),
                    'fiatAmount': Decimal('1536744465.42421'),
                    'rate': Decimal('2125632375.53695'),
                    'margin': Decimal('924723277.162193'),
                    'networkFee': Decimal('1848832019.192152'),
                },
                'update': {
                    'userId': 'daafgidjg',
                    'orderType': enums.OrderType.BUY,
                    'coinSymbol': 'gdcgcgagj',
                    'network': 'bhceabbgja',
                    'cryptoAmount': Decimal('470157467.120920'),
                    'fiatAmount': Decimal('1536744465.42421'),
                    'rate': Decimal('2125632375.53695'),
                    'margin': Decimal('924723277.162193'),
                    'networkFee': Decimal('1848832019.192152'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CryptoOrderUpdateManyMutationInput,
        where: types.CryptoOrderWhereInput,
    ) -> int:
        """Update multiple CryptoOrder records

        Parameters
        ----------
        data
            CryptoOrder data to update the selected CryptoOrder records to
        where
            Filter to select the CryptoOrder records to update

        Returns
        -------
        int
            The total number of CryptoOrder records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CryptoOrder records
        total = await CryptoOrder.prisma().update_many(
            data={
                'cryptoAmount': Decimal('510737498.211748')
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CryptoOrderWhereInput] = None,
        cursor: Optional[types.CryptoOrderWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CryptoOrder records present in the database

        Parameters
        ----------
        select
            Select the CryptoOrder fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CryptoOrder filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CryptoOrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CryptoOrder.prisma().count()

        # results: prisma.types.CryptoOrderCountAggregateOutput
        results = await CryptoOrder.prisma().count(
            select={
                '_all': True,
                'fiatAmount': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CryptoOrderCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CryptoOrderWhereInput] = None,
        cursor: Optional[types.CryptoOrderWhereUniqueInput] = None,
    ) -> types.CryptoOrderCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CryptoOrderCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CryptoOrderWhereInput] = None,
        cursor: Optional[types.CryptoOrderWhereUniqueInput] = None,
    ) -> Union[int, types.CryptoOrderCountAggregateOutput]:
        """Count the number of CryptoOrder records present in the database

        Parameters
        ----------
        select
            Select the CryptoOrder fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CryptoOrder filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CryptoOrderCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CryptoOrder.prisma().count()

        # results: prisma.types.CryptoOrderCountAggregateOutput
        results = await CryptoOrder.prisma().count(
            select={
                '_all': True,
                'rate': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CryptoOrderCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CryptoOrderWhereInput] = None
    ) -> int:
        """Delete multiple CryptoOrder records.

        Parameters
        ----------
        where
            Optional CryptoOrder filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CryptoOrder records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CryptoOrder records
        total = await CryptoOrder.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CryptoOrderScalarFieldKeys'],
        *,
        where: Optional['types.CryptoOrderWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CryptoOrderAvgAggregateInput'] = None,
        sum: Optional['types.CryptoOrderSumAggregateInput'] = None,
        min: Optional['types.CryptoOrderMinAggregateInput'] = None,
        max: Optional['types.CryptoOrderMaxAggregateInput'] = None,
        having: Optional['types.CryptoOrderScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CryptoOrderCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CryptoOrderScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CryptoOrderScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CryptoOrderGroupByOutput']:
        """Group CryptoOrder records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CryptoOrder fields to group records by
        where
            CryptoOrder filter to select records
        take
            Limit the maximum number of CryptoOrder records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CryptoOrderGroupByOutput]
            A list of dictionaries representing the CryptoOrder record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CryptoOrder records by margin values
        # and count how many records are in each group
        results = await CryptoOrder.prisma().group_by(
            ['margin'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class SettingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Setting]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Setting.prisma().query_raw(
            'SELECT * FROM Setting WHERE id = $1',
            'beabjeejdg',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Setting
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Setting.prisma().query_first(
            'SELECT * FROM Setting WHERE key = $1',
            'bcjhgahffd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.SettingCreateInput,
        include: Optional[types.SettingInclude] = None
    ) -> _PrismaModelT:
        """Create a new Setting record.

        Parameters
        ----------
        data
            Setting record data
        include
            Specifies which relations should be loaded on the returned Setting model

        Returns
        -------
        prisma.models.Setting
            The created Setting record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Setting record from just the required fields
        setting = await Setting.prisma().create(
            data={
                # data to create a Setting record
                'key': 'fbjeiiffa',
                'value': 'jhgidcgbf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.SettingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Setting records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Setting record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Setting.prisma().create_many(
            data=[
                {
                    # data to create a Setting record
                    'key': 'bgjgecfejc',
                    'value': 'bgjcgchib',
                },
                {
                    # data to create a Setting record
                    'key': 'bacdaibgfa',
                    'value': 'dchgibach',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.SettingWhereUniqueInput,
        include: Optional[types.SettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Setting record.

        Parameters
        ----------
        where
            Setting filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Setting model

        Returns
        -------
        prisma.models.Setting
            The deleted Setting record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        setting = await Setting.prisma().delete(
            where={
                'id': 'fchheijjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.SettingWhereUniqueInput,
        include: Optional[types.SettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Setting record.

        Parameters
        ----------
        where
            Setting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Setting model

        Returns
        -------
        prisma.models.Setting
            The found Setting record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        setting = await Setting.prisma().find_unique(
            where={
                'id': 'cacjdfhejh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.SettingWhereUniqueInput,
        include: Optional[types.SettingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Setting record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Setting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Setting model

        Returns
        -------
        prisma.models.Setting
            The found Setting record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        setting = await Setting.prisma().find_unique_or_raise(
            where={
                'id': 'bdbifjhbbi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SettingWhereInput] = None,
        cursor: Optional[types.SettingWhereUniqueInput] = None,
        include: Optional[types.SettingInclude] = None,
        order: Optional[Union[types.SettingOrderByInput, List[types.SettingOrderByInput]]] = None,
        distinct: Optional[List[types.SettingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Setting records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Setting records returned
        skip
            Ignore the first N results
        where
            Setting filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Setting model
        order
            Order the returned Setting records by any field
        distinct
            Filter Setting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Setting]
            The list of all Setting records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Setting records
        settings = await Setting.prisma().find_many(take=10)

        # find the first 5 Setting records ordered by the value field
        settings = await Setting.prisma().find_many(
            take=5,
            order={
                'value': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SettingWhereInput] = None,
        cursor: Optional[types.SettingWhereUniqueInput] = None,
        include: Optional[types.SettingInclude] = None,
        order: Optional[Union[types.SettingOrderByInput, List[types.SettingOrderByInput]]] = None,
        distinct: Optional[List[types.SettingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Setting record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Setting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Setting model
        order
            Order the returned Setting records by any field
        distinct
            Filter Setting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Setting
            The first Setting record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Setting record ordered by the createdAt field
        setting = await Setting.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.SettingWhereInput] = None,
        cursor: Optional[types.SettingWhereUniqueInput] = None,
        include: Optional[types.SettingInclude] = None,
        order: Optional[Union[types.SettingOrderByInput, List[types.SettingOrderByInput]]] = None,
        distinct: Optional[List[types.SettingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Setting record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Setting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Setting model
        order
            Order the returned Setting records by any field
        distinct
            Filter Setting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Setting
            The first Setting record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Setting record ordered by the updatedAt field
        setting = await Setting.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.SettingUpdateInput,
        where: types.SettingWhereUniqueInput,
        include: Optional[types.SettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Setting record.

        Parameters
        ----------
        data
            Setting record data specifying what to update
        where
            Setting filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Setting model

        Returns
        -------
        prisma.models.Setting
            The updated Setting record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        setting = await Setting.prisma().update(
            where={
                'id': 'cbccbbcdfb',
            },
            data={
                # data to update the Setting record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.SettingWhereUniqueInput,
        data: types.SettingUpsertInput,
        include: Optional[types.SettingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Setting filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Setting model

        Returns
        -------
        prisma.models.Setting
            The created or updated Setting record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        setting = await Setting.prisma().upsert(
            where={
                'id': 'bacejedaca',
            },
            data={
                'create': {
                    'id': 'bacejedaca',
                    'key': 'bacdaibgfa',
                    'value': 'dchgibach',
                },
                'update': {
                    'key': 'bacdaibgfa',
                    'value': 'dchgibach',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.SettingUpdateManyMutationInput,
        where: types.SettingWhereInput,
    ) -> int:
        """Update multiple Setting records

        Parameters
        ----------
        data
            Setting data to update the selected Setting records to
        where
            Filter to select the Setting records to update

        Returns
        -------
        int
            The total number of Setting records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Setting records
        total = await Setting.prisma().update_many(
            data={
                'id': 'bhbhdahfaj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SettingWhereInput] = None,
        cursor: Optional[types.SettingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Setting records present in the database

        Parameters
        ----------
        select
            Select the Setting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Setting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Setting.prisma().count()

        # results: prisma.types.SettingCountAggregateOutput
        results = await Setting.prisma().count(
            select={
                '_all': True,
                'key': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.SettingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SettingWhereInput] = None,
        cursor: Optional[types.SettingWhereUniqueInput] = None,
    ) -> types.SettingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.SettingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.SettingWhereInput] = None,
        cursor: Optional[types.SettingWhereUniqueInput] = None,
    ) -> Union[int, types.SettingCountAggregateOutput]:
        """Count the number of Setting records present in the database

        Parameters
        ----------
        select
            Select the Setting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Setting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.SettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Setting.prisma().count()

        # results: prisma.types.SettingCountAggregateOutput
        results = await Setting.prisma().count(
            select={
                '_all': True,
                'value': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.SettingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.SettingWhereInput] = None
    ) -> int:
        """Delete multiple Setting records.

        Parameters
        ----------
        where
            Optional Setting filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Setting records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Setting records
        total = await Setting.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.SettingScalarFieldKeys'],
        *,
        where: Optional['types.SettingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.SettingAvgAggregateInput'] = None,
        sum: Optional['types.SettingSumAggregateInput'] = None,
        min: Optional['types.SettingMinAggregateInput'] = None,
        max: Optional['types.SettingMaxAggregateInput'] = None,
        having: Optional['types.SettingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.SettingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.SettingScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.SettingScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.SettingGroupByOutput']:
        """Group Setting records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Setting fields to group records by
        where
            Setting filter to select records
        take
            Limit the maximum number of Setting records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.SettingGroupByOutput]
            A list of dictionaries representing the Setting record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Setting records by createdAt values
        # and count how many records are in each group
        results = await Setting.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class CoinSettingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.CoinSetting]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await CoinSetting.prisma().query_raw(
            'SELECT * FROM CoinSetting WHERE id = $1',
            'bfjibceaec',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.CoinSetting
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await CoinSetting.prisma().query_first(
            'SELECT * FROM CoinSetting WHERE coinSymbol = $1',
            'ibhgcdbgd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CoinSettingCreateInput,
        include: Optional[types.CoinSettingInclude] = None
    ) -> _PrismaModelT:
        """Create a new CoinSetting record.

        Parameters
        ----------
        data
            CoinSetting record data
        include
            Specifies which relations should be loaded on the returned CoinSetting model

        Returns
        -------
        prisma.models.CoinSetting
            The created CoinSetting record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a CoinSetting record from just the required fields
        coinsetting = await CoinSetting.prisma().create(
            data={
                # data to create a CoinSetting record
                'coinSymbol': 'badaffhddg',
                'network': 'bbdbfcfihd',
                'buyMargin': Decimal('210666198.127605'),
                'sellMargin': Decimal('745569348.30787'),
                'minBuy': Decimal('1674049122.152685'),
                'maxBuy': Decimal('958077104.151305'),
                'minSell': Decimal('204674734.206765'),
                'maxSell': Decimal('1183911900.158970'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CoinSettingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple CoinSetting records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of CoinSetting record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await CoinSetting.prisma().create_many(
            data=[
                {
                    # data to create a CoinSetting record
                    'coinSymbol': 'bcedehfiji',
                    'network': 'bdgjicijhb',
                    'buyMargin': Decimal('1678593480.40352'),
                    'sellMargin': Decimal('648760710.60732'),
                    'minBuy': Decimal('1468890740.62903'),
                    'maxBuy': Decimal('1214168082.89861'),
                    'minSell': Decimal('658378208.95462'),
                    'maxSell': Decimal('1214809950.104782'),
                },
                {
                    # data to create a CoinSetting record
                    'coinSymbol': 'bdachdeiga',
                    'network': 'ijdafccef',
                    'buyMargin': Decimal('280083306.54966'),
                    'sellMargin': Decimal('76790008.209829'),
                    'minBuy': Decimal('245900342.81186'),
                    'maxBuy': Decimal('1388801188.75257'),
                    'minSell': Decimal('1187663298.76968'),
                    'maxSell': Decimal('1214295824.102141'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CoinSettingWhereUniqueInput,
        include: Optional[types.CoinSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single CoinSetting record.

        Parameters
        ----------
        where
            CoinSetting filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned CoinSetting model

        Returns
        -------
        prisma.models.CoinSetting
            The deleted CoinSetting record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        coinsetting = await CoinSetting.prisma().delete(
            where={
                'id': 'dfbfaddhe',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CoinSettingWhereUniqueInput,
        include: Optional[types.CoinSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique CoinSetting record.

        Parameters
        ----------
        where
            CoinSetting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CoinSetting model

        Returns
        -------
        prisma.models.CoinSetting
            The found CoinSetting record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        coinsetting = await CoinSetting.prisma().find_unique(
            where={
                'id': 'bdcbbieibf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CoinSettingWhereUniqueInput,
        include: Optional[types.CoinSettingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique CoinSetting record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            CoinSetting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned CoinSetting model

        Returns
        -------
        prisma.models.CoinSetting
            The found CoinSetting record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        coinsetting = await CoinSetting.prisma().find_unique_or_raise(
            where={
                'id': 'dgjhdcggi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CoinSettingWhereInput] = None,
        cursor: Optional[types.CoinSettingWhereUniqueInput] = None,
        include: Optional[types.CoinSettingInclude] = None,
        order: Optional[Union[types.CoinSettingOrderByInput, List[types.CoinSettingOrderByInput]]] = None,
        distinct: Optional[List[types.CoinSettingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple CoinSetting records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of CoinSetting records returned
        skip
            Ignore the first N results
        where
            CoinSetting filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CoinSetting model
        order
            Order the returned CoinSetting records by any field
        distinct
            Filter CoinSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.CoinSetting]
            The list of all CoinSetting records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 CoinSetting records
        coinsettings = await CoinSetting.prisma().find_many(take=10)

        # find the first 5 CoinSetting records ordered by the network field
        coinsettings = await CoinSetting.prisma().find_many(
            take=5,
            order={
                'network': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CoinSettingWhereInput] = None,
        cursor: Optional[types.CoinSettingWhereUniqueInput] = None,
        include: Optional[types.CoinSettingInclude] = None,
        order: Optional[Union[types.CoinSettingOrderByInput, List[types.CoinSettingOrderByInput]]] = None,
        distinct: Optional[List[types.CoinSettingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single CoinSetting record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CoinSetting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CoinSetting model
        order
            Order the returned CoinSetting records by any field
        distinct
            Filter CoinSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CoinSetting
            The first CoinSetting record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CoinSetting record ordered by the buyMargin field
        coinsetting = await CoinSetting.prisma().find_first(
            skip=1,
            order={
                'buyMargin': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CoinSettingWhereInput] = None,
        cursor: Optional[types.CoinSettingWhereUniqueInput] = None,
        include: Optional[types.CoinSettingInclude] = None,
        order: Optional[Union[types.CoinSettingOrderByInput, List[types.CoinSettingOrderByInput]]] = None,
        distinct: Optional[List[types.CoinSettingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single CoinSetting record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            CoinSetting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned CoinSetting model
        order
            Order the returned CoinSetting records by any field
        distinct
            Filter CoinSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.CoinSetting
            The first CoinSetting record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second CoinSetting record ordered by the sellMargin field
        coinsetting = await CoinSetting.prisma().find_first_or_raise(
            skip=1,
            order={
                'sellMargin': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CoinSettingUpdateInput,
        where: types.CoinSettingWhereUniqueInput,
        include: Optional[types.CoinSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single CoinSetting record.

        Parameters
        ----------
        data
            CoinSetting record data specifying what to update
        where
            CoinSetting filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned CoinSetting model

        Returns
        -------
        prisma.models.CoinSetting
            The updated CoinSetting record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        coinsetting = await CoinSetting.prisma().update(
            where={
                'id': 'bbjbcdfabd',
            },
            data={
                # data to update the CoinSetting record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CoinSettingWhereUniqueInput,
        data: types.CoinSettingUpsertInput,
        include: Optional[types.CoinSettingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            CoinSetting filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned CoinSetting model

        Returns
        -------
        prisma.models.CoinSetting
            The created or updated CoinSetting record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        coinsetting = await CoinSetting.prisma().upsert(
            where={
                'id': 'gchfgbcec',
            },
            data={
                'create': {
                    'id': 'gchfgbcec',
                    'coinSymbol': 'bdachdeiga',
                    'network': 'ijdafccef',
                    'buyMargin': Decimal('280083306.54966'),
                    'sellMargin': Decimal('76790008.209829'),
                    'minBuy': Decimal('245900342.81186'),
                    'maxBuy': Decimal('1388801188.75257'),
                    'minSell': Decimal('1187663298.76968'),
                    'maxSell': Decimal('1214295824.102141'),
                },
                'update': {
                    'coinSymbol': 'bdachdeiga',
                    'network': 'ijdafccef',
                    'buyMargin': Decimal('280083306.54966'),
                    'sellMargin': Decimal('76790008.209829'),
                    'minBuy': Decimal('245900342.81186'),
                    'maxBuy': Decimal('1388801188.75257'),
                    'minSell': Decimal('1187663298.76968'),
                    'maxSell': Decimal('1214295824.102141'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CoinSettingUpdateManyMutationInput,
        where: types.CoinSettingWhereInput,
    ) -> int:
        """Update multiple CoinSetting records

        Parameters
        ----------
        data
            CoinSetting data to update the selected CoinSetting records to
        where
            Filter to select the CoinSetting records to update

        Returns
        -------
        int
            The total number of CoinSetting records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all CoinSetting records
        total = await CoinSetting.prisma().update_many(
            data={
                'isActive': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CoinSettingWhereInput] = None,
        cursor: Optional[types.CoinSettingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of CoinSetting records present in the database

        Parameters
        ----------
        select
            Select the CoinSetting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CoinSetting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CoinSettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CoinSetting.prisma().count()

        # results: prisma.types.CoinSettingCountAggregateOutput
        results = await CoinSetting.prisma().count(
            select={
                '_all': True,
                'minBuy': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CoinSettingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CoinSettingWhereInput] = None,
        cursor: Optional[types.CoinSettingWhereUniqueInput] = None,
    ) -> types.CoinSettingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CoinSettingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CoinSettingWhereInput] = None,
        cursor: Optional[types.CoinSettingWhereUniqueInput] = None,
    ) -> Union[int, types.CoinSettingCountAggregateOutput]:
        """Count the number of CoinSetting records present in the database

        Parameters
        ----------
        select
            Select the CoinSetting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            CoinSetting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CoinSettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await CoinSetting.prisma().count()

        # results: prisma.types.CoinSettingCountAggregateOutput
        results = await CoinSetting.prisma().count(
            select={
                '_all': True,
                'maxBuy': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CoinSettingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CoinSettingWhereInput] = None
    ) -> int:
        """Delete multiple CoinSetting records.

        Parameters
        ----------
        where
            Optional CoinSetting filter to find the records to be deleted

        Returns
        -------
        int
            The total number of CoinSetting records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all CoinSetting records
        total = await CoinSetting.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CoinSettingScalarFieldKeys'],
        *,
        where: Optional['types.CoinSettingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CoinSettingAvgAggregateInput'] = None,
        sum: Optional['types.CoinSettingSumAggregateInput'] = None,
        min: Optional['types.CoinSettingMinAggregateInput'] = None,
        max: Optional['types.CoinSettingMaxAggregateInput'] = None,
        having: Optional['types.CoinSettingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CoinSettingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CoinSettingScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CoinSettingScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CoinSettingGroupByOutput']:
        """Group CoinSetting records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar CoinSetting fields to group records by
        where
            CoinSetting filter to select records
        take
            Limit the maximum number of CoinSetting records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CoinSettingGroupByOutput]
            A list of dictionaries representing the CoinSetting record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group CoinSetting records by minSell values
        # and count how many records are in each group
        results = await CoinSetting.prisma().group_by(
            ['minSell'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PaymentMethodActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.PaymentMethod]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await PaymentMethod.prisma().query_raw(
            'SELECT * FROM PaymentMethod WHERE id = $1',
            'bhjdcicaii',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.PaymentMethod
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await PaymentMethod.prisma().query_first(
            'SELECT * FROM PaymentMethod WHERE type = $1',
            'bibedjhcej',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PaymentMethodCreateInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> _PrismaModelT:
        """Create a new PaymentMethod record.

        Parameters
        ----------
        data
            PaymentMethod record data
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The created PaymentMethod record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a PaymentMethod record from just the required fields
        paymentmethod = await PaymentMethod.prisma().create(
            data={
                # data to create a PaymentMethod record
                'type': 'bjcdajabfa',
                'name': 'bchhceeeff',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PaymentMethodCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple PaymentMethod records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of PaymentMethod record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await PaymentMethod.prisma().create_many(
            data=[
                {
                    # data to create a PaymentMethod record
                    'type': 'bbgaifhdaa',
                    'name': 'dgbcdaegb',
                },
                {
                    # data to create a PaymentMethod record
                    'type': 'beagfbbjig',
                    'name': 'beicihhijb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single PaymentMethod record.

        Parameters
        ----------
        where
            PaymentMethod filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The deleted PaymentMethod record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().delete(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique PaymentMethod record.

        Parameters
        ----------
        where
            PaymentMethod filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The found PaymentMethod record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().find_unique(
            where={
                'id': 'ccjbbjigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> _PrismaModelT:
        """Find a unique PaymentMethod record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            PaymentMethod filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The found PaymentMethod record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().find_unique_or_raise(
            where={
                'id': 'bhfaabbaha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
        include: Optional[types.PaymentMethodInclude] = None,
        order: Optional[Union[types.PaymentMethodOrderByInput, List[types.PaymentMethodOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentMethodScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple PaymentMethod records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of PaymentMethod records returned
        skip
            Ignore the first N results
        where
            PaymentMethod filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PaymentMethod model
        order
            Order the returned PaymentMethod records by any field
        distinct
            Filter PaymentMethod records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.PaymentMethod]
            The list of all PaymentMethod records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 PaymentMethod records
        paymentmethods = await PaymentMethod.prisma().find_many(take=10)

        # find the first 5 PaymentMethod records ordered by the name field
        paymentmethods = await PaymentMethod.prisma().find_many(
            take=5,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
        include: Optional[types.PaymentMethodInclude] = None,
        order: Optional[Union[types.PaymentMethodOrderByInput, List[types.PaymentMethodOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentMethodScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single PaymentMethod record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PaymentMethod filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PaymentMethod model
        order
            Order the returned PaymentMethod records by any field
        distinct
            Filter PaymentMethod records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PaymentMethod
            The first PaymentMethod record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PaymentMethod record ordered by the accountNo field
        paymentmethod = await PaymentMethod.prisma().find_first(
            skip=1,
            order={
                'accountNo': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
        include: Optional[types.PaymentMethodInclude] = None,
        order: Optional[Union[types.PaymentMethodOrderByInput, List[types.PaymentMethodOrderByInput]]] = None,
        distinct: Optional[List[types.PaymentMethodScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single PaymentMethod record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            PaymentMethod filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned PaymentMethod model
        order
            Order the returned PaymentMethod records by any field
        distinct
            Filter PaymentMethod records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.PaymentMethod
            The first PaymentMethod record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second PaymentMethod record ordered by the accountName field
        paymentmethod = await PaymentMethod.prisma().find_first_or_raise(
            skip=1,
            order={
                'accountName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PaymentMethodUpdateInput,
        where: types.PaymentMethodWhereUniqueInput,
        include: Optional[types.PaymentMethodInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single PaymentMethod record.

        Parameters
        ----------
        data
            PaymentMethod record data specifying what to update
        where
            PaymentMethod filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The updated PaymentMethod record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().update(
            where={
                'id': 'ebajedhhf',
            },
            data={
                # data to update the PaymentMethod record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PaymentMethodWhereUniqueInput,
        data: types.PaymentMethodUpsertInput,
        include: Optional[types.PaymentMethodInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            PaymentMethod filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned PaymentMethod model

        Returns
        -------
        prisma.models.PaymentMethod
            The created or updated PaymentMethod record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        paymentmethod = await PaymentMethod.prisma().upsert(
            where={
                'id': 'jajacedge',
            },
            data={
                'create': {
                    'id': 'jajacedge',
                    'type': 'beagfbbjig',
                    'name': 'beicihhijb',
                },
                'update': {
                    'type': 'beagfbbjig',
                    'name': 'beicihhijb',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PaymentMethodUpdateManyMutationInput,
        where: types.PaymentMethodWhereInput,
    ) -> int:
        """Update multiple PaymentMethod records

        Parameters
        ----------
        data
            PaymentMethod data to update the selected PaymentMethod records to
        where
            Filter to select the PaymentMethod records to update

        Returns
        -------
        int
            The total number of PaymentMethod records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all PaymentMethod records
        total = await PaymentMethod.prisma().update_many(
            data={
                'isActive': False
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
    ) -> int:
        """Count the number of PaymentMethod records present in the database

        Parameters
        ----------
        select
            Select the PaymentMethod fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PaymentMethod filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentMethodCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PaymentMethod.prisma().count()

        # results: prisma.types.PaymentMethodCountAggregateOutput
        results = await PaymentMethod.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PaymentMethodCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
    ) -> types.PaymentMethodCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PaymentMethodCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PaymentMethodWhereInput] = None,
        cursor: Optional[types.PaymentMethodWhereUniqueInput] = None,
    ) -> Union[int, types.PaymentMethodCountAggregateOutput]:
        """Count the number of PaymentMethod records present in the database

        Parameters
        ----------
        select
            Select the PaymentMethod fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            PaymentMethod filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PaymentMethodCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await PaymentMethod.prisma().count()

        # results: prisma.types.PaymentMethodCountAggregateOutput
        results = await PaymentMethod.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PaymentMethodCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PaymentMethodWhereInput] = None
    ) -> int:
        """Delete multiple PaymentMethod records.

        Parameters
        ----------
        where
            Optional PaymentMethod filter to find the records to be deleted

        Returns
        -------
        int
            The total number of PaymentMethod records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all PaymentMethod records
        total = await PaymentMethod.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PaymentMethodScalarFieldKeys'],
        *,
        where: Optional['types.PaymentMethodWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PaymentMethodAvgAggregateInput'] = None,
        sum: Optional['types.PaymentMethodSumAggregateInput'] = None,
        min: Optional['types.PaymentMethodMinAggregateInput'] = None,
        max: Optional['types.PaymentMethodMaxAggregateInput'] = None,
        having: Optional['types.PaymentMethodScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PaymentMethodCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PaymentMethodScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PaymentMethodScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PaymentMethodGroupByOutput']:
        """Group PaymentMethod records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar PaymentMethod fields to group records by
        where
            PaymentMethod filter to select records
        take
            Limit the maximum number of PaymentMethod records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PaymentMethodGroupByOutput]
            A list of dictionaries representing the PaymentMethod record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group PaymentMethod records by id values
        # and count how many records are in each group
        results = await PaymentMethod.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class AdminActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Admin]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Admin.prisma().query_raw(
            'SELECT * FROM Admin WHERE id = $1',
            'biacbiieja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Admin
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Admin.prisma().query_first(
            'SELECT * FROM Admin WHERE username = $1',
            'cjejbgbff',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.AdminCreateInput,
        include: Optional[types.AdminInclude] = None
    ) -> _PrismaModelT:
        """Create a new Admin record.

        Parameters
        ----------
        data
            Admin record data
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The created Admin record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Admin record from just the required fields
        admin = await Admin.prisma().create(
            data={
                # data to create a Admin record
                'username': 'fgeahddae',
                'passwordHash': 'diageigcf',
                'name': 'badagbgeha',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.AdminCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Admin records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Admin record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Admin.prisma().create_many(
            data=[
                {
                    # data to create a Admin record
                    'username': 'ibgebbjch',
                    'passwordHash': 'baieajjiee',
                    'name': 'bahjhaccfd',
                },
                {
                    # data to create a Admin record
                    'username': 'hffhfabhi',
                    'passwordHash': 'bbcigiadhb',
                    'name': 'cfjagbbae',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Admin record.

        Parameters
        ----------
        where
            Admin filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The deleted Admin record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().delete(
            where={
                'id': 'bbbfhdidef',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Admin record.

        Parameters
        ----------
        where
            Admin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The found Admin record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().find_unique(
            where={
                'id': 'bdadhibhec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Admin record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Admin filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The found Admin record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().find_unique_or_raise(
            where={
                'id': 'bfhdjaiejf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
        include: Optional[types.AdminInclude] = None,
        order: Optional[Union[types.AdminOrderByInput, List[types.AdminOrderByInput]]] = None,
        distinct: Optional[List[types.AdminScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Admin records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Admin records returned
        skip
            Ignore the first N results
        where
            Admin filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Admin model
        order
            Order the returned Admin records by any field
        distinct
            Filter Admin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Admin]
            The list of all Admin records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Admin records
        admins = await Admin.prisma().find_many(take=10)

        # find the first 5 Admin records ordered by the passwordHash field
        admins = await Admin.prisma().find_many(
            take=5,
            order={
                'passwordHash': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
        include: Optional[types.AdminInclude] = None,
        order: Optional[Union[types.AdminOrderByInput, List[types.AdminOrderByInput]]] = None,
        distinct: Optional[List[types.AdminScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Admin record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Admin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Admin model
        order
            Order the returned Admin records by any field
        distinct
            Filter Admin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Admin
            The first Admin record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Admin record ordered by the name field
        admin = await Admin.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
        include: Optional[types.AdminInclude] = None,
        order: Optional[Union[types.AdminOrderByInput, List[types.AdminOrderByInput]]] = None,
        distinct: Optional[List[types.AdminScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Admin record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Admin filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Admin model
        order
            Order the returned Admin records by any field
        distinct
            Filter Admin records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Admin
            The first Admin record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Admin record ordered by the isActive field
        admin = await Admin.prisma().find_first_or_raise(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.AdminUpdateInput,
        where: types.AdminWhereUniqueInput,
        include: Optional[types.AdminInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Admin record.

        Parameters
        ----------
        data
            Admin record data specifying what to update
        where
            Admin filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The updated Admin record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        admin = await Admin.prisma().update(
            where={
                'id': 'bbjfijjadg',
            },
            data={
                # data to update the Admin record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.AdminWhereUniqueInput,
        data: types.AdminUpsertInput,
        include: Optional[types.AdminInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Admin filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Admin model

        Returns
        -------
        prisma.models.Admin
            The created or updated Admin record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        admin = await Admin.prisma().upsert(
            where={
                'id': 'hdjacbehh',
            },
            data={
                'create': {
                    'id': 'hdjacbehh',
                    'username': 'hffhfabhi',
                    'passwordHash': 'bbcigiadhb',
                    'name': 'cfjagbbae',
                },
                'update': {
                    'username': 'hffhfabhi',
                    'passwordHash': 'bbcigiadhb',
                    'name': 'cfjagbbae',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.AdminUpdateManyMutationInput,
        where: types.AdminWhereInput,
    ) -> int:
        """Update multiple Admin records

        Parameters
        ----------
        data
            Admin data to update the selected Admin records to
        where
            Filter to select the Admin records to update

        Returns
        -------
        int
            The total number of Admin records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Admin records
        total = await Admin.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Admin records present in the database

        Parameters
        ----------
        select
            Select the Admin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Admin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdminCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Admin.prisma().count()

        # results: prisma.types.AdminCountAggregateOutput
        results = await Admin.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.AdminCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
    ) -> types.AdminCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.AdminCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.AdminWhereInput] = None,
        cursor: Optional[types.AdminWhereUniqueInput] = None,
    ) -> Union[int, types.AdminCountAggregateOutput]:
        """Count the number of Admin records present in the database

        Parameters
        ----------
        select
            Select the Admin fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Admin filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.AdminCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Admin.prisma().count()

        # results: prisma.types.AdminCountAggregateOutput
        results = await Admin.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.AdminCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.AdminWhereInput] = None
    ) -> int:
        """Delete multiple Admin records.

        Parameters
        ----------
        where
            Optional Admin filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Admin records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Admin records
        total = await Admin.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.AdminScalarFieldKeys'],
        *,
        where: Optional['types.AdminWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.AdminAvgAggregateInput'] = None,
        sum: Optional['types.AdminSumAggregateInput'] = None,
        min: Optional['types.AdminMinAggregateInput'] = None,
        max: Optional['types.AdminMaxAggregateInput'] = None,
        having: Optional['types.AdminScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.AdminCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.AdminScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.AdminScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.AdminGroupByOutput']:
        """Group Admin records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Admin fields to group records by
        where
            Admin filter to select records
        take
            Limit the maximum number of Admin records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.AdminGroupByOutput]
            A list of dictionaries representing the Admin record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Admin records by username values
        # and count how many records are in each group
        results = await Admin.prisma().group_by(
            ['username'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReferralSettingActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ReferralSetting]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ReferralSetting.prisma().query_raw(
            'SELECT * FROM ReferralSetting WHERE id = $1',
            'bhcccbeaba',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ReferralSetting
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ReferralSetting.prisma().query_first(
            'SELECT * FROM ReferralSetting WHERE referrerBonus = $1',
            Decimal('1269136939.57317'),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReferralSettingCreateInput,
        include: Optional[types.ReferralSettingInclude] = None
    ) -> _PrismaModelT:
        """Create a new ReferralSetting record.

        Parameters
        ----------
        data
            ReferralSetting record data
        include
            Specifies which relations should be loaded on the returned ReferralSetting model

        Returns
        -------
        prisma.models.ReferralSetting
            The created ReferralSetting record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ReferralSetting record from just the required fields
        referralsetting = await ReferralSetting.prisma().create(
            data={
                # data to create a ReferralSetting record
                'referrerBonus': Decimal('1440265249.118573'),
                'refereeBonus': Decimal('1694224903.190636'),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReferralSettingCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ReferralSetting records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ReferralSetting record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ReferralSetting.prisma().create_many(
            data=[
                {
                    # data to create a ReferralSetting record
                    'referrerBonus': Decimal('1911255389.14626'),
                    'refereeBonus': Decimal('1719240611.194855'),
                },
                {
                    # data to create a ReferralSetting record
                    'referrerBonus': Decimal('1383253593.35466'),
                    'refereeBonus': Decimal('647166719.35708'),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReferralSettingWhereUniqueInput,
        include: Optional[types.ReferralSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ReferralSetting record.

        Parameters
        ----------
        where
            ReferralSetting filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ReferralSetting model

        Returns
        -------
        prisma.models.ReferralSetting
            The deleted ReferralSetting record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        referralsetting = await ReferralSetting.prisma().delete(
            where={
                'id': 'gbcdjgicb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReferralSettingWhereUniqueInput,
        include: Optional[types.ReferralSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ReferralSetting record.

        Parameters
        ----------
        where
            ReferralSetting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReferralSetting model

        Returns
        -------
        prisma.models.ReferralSetting
            The found ReferralSetting record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        referralsetting = await ReferralSetting.prisma().find_unique(
            where={
                'id': 'biaibdagac',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReferralSettingWhereUniqueInput,
        include: Optional[types.ReferralSettingInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ReferralSetting record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ReferralSetting filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ReferralSetting model

        Returns
        -------
        prisma.models.ReferralSetting
            The found ReferralSetting record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        referralsetting = await ReferralSetting.prisma().find_unique_or_raise(
            where={
                'id': 'bbfbheibcd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReferralSettingWhereInput] = None,
        cursor: Optional[types.ReferralSettingWhereUniqueInput] = None,
        include: Optional[types.ReferralSettingInclude] = None,
        order: Optional[Union[types.ReferralSettingOrderByInput, List[types.ReferralSettingOrderByInput]]] = None,
        distinct: Optional[List[types.ReferralSettingScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ReferralSetting records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ReferralSetting records returned
        skip
            Ignore the first N results
        where
            ReferralSetting filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReferralSetting model
        order
            Order the returned ReferralSetting records by any field
        distinct
            Filter ReferralSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ReferralSetting]
            The list of all ReferralSetting records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ReferralSetting records
        referralsettings = await ReferralSetting.prisma().find_many(take=10)

        # find the first 5 ReferralSetting records ordered by the refereeBonus field
        referralsettings = await ReferralSetting.prisma().find_many(
            take=5,
            order={
                'refereeBonus': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReferralSettingWhereInput] = None,
        cursor: Optional[types.ReferralSettingWhereUniqueInput] = None,
        include: Optional[types.ReferralSettingInclude] = None,
        order: Optional[Union[types.ReferralSettingOrderByInput, List[types.ReferralSettingOrderByInput]]] = None,
        distinct: Optional[List[types.ReferralSettingScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ReferralSetting record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReferralSetting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReferralSetting model
        order
            Order the returned ReferralSetting records by any field
        distinct
            Filter ReferralSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReferralSetting
            The first ReferralSetting record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReferralSetting record ordered by the isActive field
        referralsetting = await ReferralSetting.prisma().find_first(
            skip=1,
            order={
                'isActive': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReferralSettingWhereInput] = None,
        cursor: Optional[types.ReferralSettingWhereUniqueInput] = None,
        include: Optional[types.ReferralSettingInclude] = None,
        order: Optional[Union[types.ReferralSettingOrderByInput, List[types.ReferralSettingOrderByInput]]] = None,
        distinct: Optional[List[types.ReferralSettingScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ReferralSetting record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ReferralSetting filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ReferralSetting model
        order
            Order the returned ReferralSetting records by any field
        distinct
            Filter ReferralSetting records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ReferralSetting
            The first ReferralSetting record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ReferralSetting record ordered by the createdAt field
        referralsetting = await ReferralSetting.prisma().find_first_or_raise(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReferralSettingUpdateInput,
        where: types.ReferralSettingWhereUniqueInput,
        include: Optional[types.ReferralSettingInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ReferralSetting record.

        Parameters
        ----------
        data
            ReferralSetting record data specifying what to update
        where
            ReferralSetting filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ReferralSetting model

        Returns
        -------
        prisma.models.ReferralSetting
            The updated ReferralSetting record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        referralsetting = await ReferralSetting.prisma().update(
            where={
                'id': 'hiagajie',
            },
            data={
                # data to update the ReferralSetting record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReferralSettingWhereUniqueInput,
        data: types.ReferralSettingUpsertInput,
        include: Optional[types.ReferralSettingInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ReferralSetting filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ReferralSetting model

        Returns
        -------
        prisma.models.ReferralSetting
            The created or updated ReferralSetting record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        referralsetting = await ReferralSetting.prisma().upsert(
            where={
                'id': 'eeejidbif',
            },
            data={
                'create': {
                    'id': 'eeejidbif',
                    'referrerBonus': Decimal('1383253593.35466'),
                    'refereeBonus': Decimal('647166719.35708'),
                },
                'update': {
                    'referrerBonus': Decimal('1383253593.35466'),
                    'refereeBonus': Decimal('647166719.35708'),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReferralSettingUpdateManyMutationInput,
        where: types.ReferralSettingWhereInput,
    ) -> int:
        """Update multiple ReferralSetting records

        Parameters
        ----------
        data
            ReferralSetting data to update the selected ReferralSetting records to
        where
            Filter to select the ReferralSetting records to update

        Returns
        -------
        int
            The total number of ReferralSetting records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ReferralSetting records
        total = await ReferralSetting.prisma().update_many(
            data={
                'updatedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReferralSettingWhereInput] = None,
        cursor: Optional[types.ReferralSettingWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ReferralSetting records present in the database

        Parameters
        ----------
        select
            Select the ReferralSetting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReferralSetting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReferralSettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReferralSetting.prisma().count()

        # results: prisma.types.ReferralSettingCountAggregateOutput
        results = await ReferralSetting.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReferralSettingCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReferralSettingWhereInput] = None,
        cursor: Optional[types.ReferralSettingWhereUniqueInput] = None,
    ) -> types.ReferralSettingCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReferralSettingCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReferralSettingWhereInput] = None,
        cursor: Optional[types.ReferralSettingWhereUniqueInput] = None,
    ) -> Union[int, types.ReferralSettingCountAggregateOutput]:
        """Count the number of ReferralSetting records present in the database

        Parameters
        ----------
        select
            Select the ReferralSetting fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ReferralSetting filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReferralSettingCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ReferralSetting.prisma().count()

        # results: prisma.types.ReferralSettingCountAggregateOutput
        results = await ReferralSetting.prisma().count(
            select={
                '_all': True,
                'referrerBonus': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReferralSettingCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReferralSettingWhereInput] = None
    ) -> int:
        """Delete multiple ReferralSetting records.

        Parameters
        ----------
        where
            Optional ReferralSetting filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ReferralSetting records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ReferralSetting records
        total = await ReferralSetting.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReferralSettingScalarFieldKeys'],
        *,
        where: Optional['types.ReferralSettingWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReferralSettingAvgAggregateInput'] = None,
        sum: Optional['types.ReferralSettingSumAggregateInput'] = None,
        min: Optional['types.ReferralSettingMinAggregateInput'] = None,
        max: Optional['types.ReferralSettingMaxAggregateInput'] = None,
        having: Optional['types.ReferralSettingScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReferralSettingCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReferralSettingScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReferralSettingScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReferralSettingGroupByOutput']:
        """Group ReferralSetting records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ReferralSetting fields to group records by
        where
            ReferralSetting filter to select records
        take
            Limit the maximum number of ReferralSetting records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReferralSettingGroupByOutput]
            A list of dictionaries representing the ReferralSetting record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ReferralSetting records by refereeBonus values
        # and count how many records are in each group
        results = await ReferralSetting.prisma().group_by(
            ['refereeBonus'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models