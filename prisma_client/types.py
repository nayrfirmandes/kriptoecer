# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
        'search': str,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _UserStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.UserStatus']]


class _UserStatusListFilterHasInput(TypedDict):
    has: 'enums.UserStatus'


class _UserStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.UserStatus']


class _UserStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.UserStatus']


class _UserStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


UserStatusListFilter = Union[
    _UserStatusListFilterHasInput,
    _UserStatusListFilterEqualsInput,
    _UserStatusListFilterHasSomeInput,
    _UserStatusListFilterIsEmptyInput,
    _UserStatusListFilterHasEveryInput,
]


class _UserStatusListUpdateSet(TypedDict):
    set: List['enums.UserStatus']


class _UserStatusListUpdatePush(TypedDict):
    push: List['enums.UserStatus']


UserStatusListUpdate = Union[
    List['enums.UserStatus'],
    _UserStatusListUpdateSet,
    _UserStatusListUpdatePush,
]

class _TransactionTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.TransactionType']]


class _TransactionTypeListFilterHasInput(TypedDict):
    has: 'enums.TransactionType'


class _TransactionTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.TransactionType']


class _TransactionTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.TransactionType']


class _TransactionTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TransactionTypeListFilter = Union[
    _TransactionTypeListFilterHasInput,
    _TransactionTypeListFilterEqualsInput,
    _TransactionTypeListFilterHasSomeInput,
    _TransactionTypeListFilterIsEmptyInput,
    _TransactionTypeListFilterHasEveryInput,
]


class _TransactionTypeListUpdateSet(TypedDict):
    set: List['enums.TransactionType']


class _TransactionTypeListUpdatePush(TypedDict):
    push: List['enums.TransactionType']


TransactionTypeListUpdate = Union[
    List['enums.TransactionType'],
    _TransactionTypeListUpdateSet,
    _TransactionTypeListUpdatePush,
]

class _TransactionStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.TransactionStatus']]


class _TransactionStatusListFilterHasInput(TypedDict):
    has: 'enums.TransactionStatus'


class _TransactionStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.TransactionStatus']


class _TransactionStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.TransactionStatus']


class _TransactionStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


TransactionStatusListFilter = Union[
    _TransactionStatusListFilterHasInput,
    _TransactionStatusListFilterEqualsInput,
    _TransactionStatusListFilterHasSomeInput,
    _TransactionStatusListFilterIsEmptyInput,
    _TransactionStatusListFilterHasEveryInput,
]


class _TransactionStatusListUpdateSet(TypedDict):
    set: List['enums.TransactionStatus']


class _TransactionStatusListUpdatePush(TypedDict):
    push: List['enums.TransactionStatus']


TransactionStatusListUpdate = Union[
    List['enums.TransactionStatus'],
    _TransactionStatusListUpdateSet,
    _TransactionStatusListUpdatePush,
]

class _OrderTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.OrderType']]


class _OrderTypeListFilterHasInput(TypedDict):
    has: 'enums.OrderType'


class _OrderTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.OrderType']


class _OrderTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.OrderType']


class _OrderTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


OrderTypeListFilter = Union[
    _OrderTypeListFilterHasInput,
    _OrderTypeListFilterEqualsInput,
    _OrderTypeListFilterHasSomeInput,
    _OrderTypeListFilterIsEmptyInput,
    _OrderTypeListFilterHasEveryInput,
]


class _OrderTypeListUpdateSet(TypedDict):
    set: List['enums.OrderType']


class _OrderTypeListUpdatePush(TypedDict):
    push: List['enums.OrderType']


OrderTypeListUpdate = Union[
    List['enums.OrderType'],
    _OrderTypeListUpdateSet,
    _OrderTypeListUpdatePush,
]

class _OrderStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.OrderStatus']]


class _OrderStatusListFilterHasInput(TypedDict):
    has: 'enums.OrderStatus'


class _OrderStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.OrderStatus']


class _OrderStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.OrderStatus']


class _OrderStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


OrderStatusListFilter = Union[
    _OrderStatusListFilterHasInput,
    _OrderStatusListFilterEqualsInput,
    _OrderStatusListFilterHasSomeInput,
    _OrderStatusListFilterIsEmptyInput,
    _OrderStatusListFilterHasEveryInput,
]


class _OrderStatusListUpdateSet(TypedDict):
    set: List['enums.OrderStatus']


class _OrderStatusListUpdatePush(TypedDict):
    push: List['enums.OrderStatus']


OrderStatusListUpdate = Union[
    List['enums.OrderStatus'],
    _OrderStatusListUpdateSet,
    _OrderStatusListUpdatePush,
]


# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    username: Optional[_str]
    firstName: Optional[_str]
    lastName: Optional[_str]
    email: Optional[_str]
    whatsapp: Optional[_str]
    latitude: Optional[_float]
    longitude: Optional[_float]
    pinHash: Optional[_str]
    referredById: Optional[_str]
    referredBy: 'UserCreateNestedWithoutRelationsInput'
    referrals: 'UserCreateManyNestedWithoutRelationsInput'
    status: 'enums.UserStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    lastActiveAt: datetime.datetime
    balance: 'BalanceCreateNestedWithoutRelationsInput'
    transactions: 'TransactionCreateManyNestedWithoutRelationsInput'
    deposits: 'DepositCreateManyNestedWithoutRelationsInput'
    withdrawals: 'WithdrawalCreateManyNestedWithoutRelationsInput'
    cryptoOrders: 'CryptoOrderCreateManyNestedWithoutRelationsInput'


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    telegramId: _int
    referralCode: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    username: Optional[_str]
    firstName: Optional[_str]
    lastName: Optional[_str]
    email: Optional[_str]
    whatsapp: Optional[_str]
    latitude: Optional[_float]
    longitude: Optional[_float]
    pinHash: Optional[_str]
    referredById: Optional[_str]
    status: 'enums.UserStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    lastActiveAt: datetime.datetime


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    telegramId: _int
    referralCode: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_telegramId_Input = TypedDict(
    '_UserWhereUnique_telegramId_Input',
    {
        'telegramId': '_int',
    },
    total=True
)

_UserWhereUnique_referralCode_Input = TypedDict(
    '_UserWhereUnique_referralCode_Input',
    {
        'referralCode': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_telegramId_Input',
    '_UserWhereUnique_referralCode_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    telegramId: Union[AtomicBigIntInput, _int]
    username: Optional[_str]
    firstName: Optional[_str]
    lastName: Optional[_str]
    email: Optional[_str]
    whatsapp: Optional[_str]
    latitude: Optional[Union[AtomicFloatInput, _float]]
    longitude: Optional[Union[AtomicFloatInput, _float]]
    pinHash: Optional[_str]
    referralCode: _str
    referredBy: 'UserUpdateOneWithoutRelationsInput'
    referrals: 'UserUpdateManyWithoutRelationsInput'
    status: 'enums.UserStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    lastActiveAt: datetime.datetime
    balance: 'BalanceUpdateOneWithoutRelationsInput'
    transactions: 'TransactionUpdateManyWithoutRelationsInput'
    deposits: 'DepositUpdateManyWithoutRelationsInput'
    withdrawals: 'WithdrawalUpdateManyWithoutRelationsInput'
    cryptoOrders: 'CryptoOrderUpdateManyWithoutRelationsInput'


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    telegramId: Union[AtomicBigIntInput, _int]
    username: Optional[_str]
    firstName: Optional[_str]
    lastName: Optional[_str]
    email: Optional[_str]
    whatsapp: Optional[_str]
    latitude: Optional[Union[AtomicFloatInput, _float]]
    longitude: Optional[Union[AtomicFloatInput, _float]]
    pinHash: Optional[_str]
    referralCode: _str
    status: 'enums.UserStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    lastActiveAt: datetime.datetime


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_telegramId_OrderByInput = TypedDict(
    '_User_telegramId_OrderByInput',
    {
        'telegramId': 'SortOrder',
    },
    total=True
)

_User_username_OrderByInput = TypedDict(
    '_User_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_User_firstName_OrderByInput = TypedDict(
    '_User_firstName_OrderByInput',
    {
        'firstName': 'SortOrder',
    },
    total=True
)

_User_lastName_OrderByInput = TypedDict(
    '_User_lastName_OrderByInput',
    {
        'lastName': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_whatsapp_OrderByInput = TypedDict(
    '_User_whatsapp_OrderByInput',
    {
        'whatsapp': 'SortOrder',
    },
    total=True
)

_User_latitude_OrderByInput = TypedDict(
    '_User_latitude_OrderByInput',
    {
        'latitude': 'SortOrder',
    },
    total=True
)

_User_longitude_OrderByInput = TypedDict(
    '_User_longitude_OrderByInput',
    {
        'longitude': 'SortOrder',
    },
    total=True
)

_User_pinHash_OrderByInput = TypedDict(
    '_User_pinHash_OrderByInput',
    {
        'pinHash': 'SortOrder',
    },
    total=True
)

_User_referralCode_OrderByInput = TypedDict(
    '_User_referralCode_OrderByInput',
    {
        'referralCode': 'SortOrder',
    },
    total=True
)

_User_referredById_OrderByInput = TypedDict(
    '_User_referredById_OrderByInput',
    {
        'referredById': 'SortOrder',
    },
    total=True
)

_User_status_OrderByInput = TypedDict(
    '_User_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_User_lastActiveAt_OrderByInput = TypedDict(
    '_User_lastActiveAt_OrderByInput',
    {
        'lastActiveAt': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_telegramId_OrderByInput',
    '_User_username_OrderByInput',
    '_User_firstName_OrderByInput',
    '_User_lastName_OrderByInput',
    '_User_email_OrderByInput',
    '_User_whatsapp_OrderByInput',
    '_User_latitude_OrderByInput',
    '_User_longitude_OrderByInput',
    '_User_pinHash_OrderByInput',
    '_User_referralCode_OrderByInput',
    '_User_referredById_OrderByInput',
    '_User_status_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
    '_User_lastActiveAt_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    referredBy: Union[bool, 'UserArgsFromUser']
    referrals: Union[bool, 'FindManyUserArgsFromUser']
    balance: Union[bool, 'BalanceArgsFromUser']
    transactions: Union[bool, 'FindManyTransactionArgsFromUser']
    deposits: Union[bool, 'FindManyDepositArgsFromUser']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromUser']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromUser']


    

class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    referredBy: Union[bool, 'UserArgsFromUserRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromUserRecursive1']
    balance: Union[bool, 'BalanceArgsFromUserRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromUserRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromUserRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromUserRecursive1']


class UserIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    referredBy: Union[bool, 'UserArgsFromUserRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromUserRecursive2']
    balance: Union[bool, 'BalanceArgsFromUserRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromUserRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromUserRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromUserRecursive2']


class UserIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    referredBy: Union[bool, 'UserArgsFromUserRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromUserRecursive3']
    balance: Union[bool, 'BalanceArgsFromUserRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromUserRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromUserRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromUserRecursive3']


class UserIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    referredBy: Union[bool, 'UserArgsFromUserRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromUserRecursive4']
    balance: Union[bool, 'BalanceArgsFromUserRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromUserRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromUserRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromUserRecursive4']


class UserIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']


class BalanceIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']


class BalanceIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']


class BalanceIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']


class BalanceIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class BalanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyBalanceArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']


class TransactionIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']


class TransactionIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']


class TransactionIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']


class TransactionIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class TransactionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyTransactionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive1']


class DepositIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive2']


class DepositIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive3']


class DepositIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive4']


class DepositIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class DepositArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyDepositArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive1']


class WithdrawalIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive2']


class WithdrawalIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive3']


class WithdrawalIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromUserRecursive4']


class WithdrawalIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class WithdrawalArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyWithdrawalArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive1']


class CryptoOrderIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive2']


class CryptoOrderIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive3']


class CryptoOrderIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUserRecursive4']


class CryptoOrderIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CryptoOrderArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCryptoOrderArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class SettingIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class SettingIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""


class SettingIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""


class SettingIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class SettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManySettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class CoinSettingIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class CoinSettingIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""


class CoinSettingIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""


class CoinSettingIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class CoinSettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyCoinSettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class PaymentMethodIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class PaymentMethodIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""


class PaymentMethodIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""


class PaymentMethodIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class PaymentMethodArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyPaymentMethodArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromUserRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive1']


class AdminIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromUserRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive2']


class AdminIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromUserRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive3']


class AdminIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromUserRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromUserRecursive4']


class AdminIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class AdminArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyAdminArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""


class ReferralSettingIncludeFromUserRecursive1(TypedDict, total=False):
    """Relational arguments for User"""


class ReferralSettingIncludeFromUserRecursive2(TypedDict, total=False):
    """Relational arguments for User"""


class ReferralSettingIncludeFromUserRecursive3(TypedDict, total=False):
    """Relational arguments for User"""


class ReferralSettingIncludeFromUserRecursive4(TypedDict, total=False):
    """Relational arguments for User"""

    

class ReferralSettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    
    

class FindManyReferralSettingArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromUserRecursive1(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromUserRecursive2(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromUserRecursive3(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromUserRecursive4(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


    

class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    telegramId: Union[_int, 'types.BigIntFilter']
    username: Union[None, _str, 'types.StringFilter']
    firstName: Union[None, _str, 'types.StringFilter']
    lastName: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    whatsapp: Union[None, _str, 'types.StringFilter']
    latitude: Union[None, _float, 'types.FloatFilter']
    longitude: Union[None, _float, 'types.FloatFilter']
    pinHash: Union[None, _str, 'types.StringFilter']
    referralCode: Union[_str, 'types.StringFilter']
    referredById: Union[None, _str, 'types.StringFilter']
    referredBy: 'UserRelationFilter'
    referrals: 'UserListRelationFilter'
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeFilter']
    balance: 'BalanceRelationFilter'
    transactions: 'TransactionListRelationFilter'
    deposits: 'DepositListRelationFilter'
    withdrawals: 'WithdrawalListRelationFilter'
    cryptoOrders: 'CryptoOrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive1', List['UserWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive1']
    OR: List['UserWhereInputRecursive1']
    NOT: List['UserWhereInputRecursive1']


class UserWhereInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    telegramId: Union[_int, 'types.BigIntFilter']
    username: Union[None, _str, 'types.StringFilter']
    firstName: Union[None, _str, 'types.StringFilter']
    lastName: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    whatsapp: Union[None, _str, 'types.StringFilter']
    latitude: Union[None, _float, 'types.FloatFilter']
    longitude: Union[None, _float, 'types.FloatFilter']
    pinHash: Union[None, _str, 'types.StringFilter']
    referralCode: Union[_str, 'types.StringFilter']
    referredById: Union[None, _str, 'types.StringFilter']
    referredBy: 'UserRelationFilter'
    referrals: 'UserListRelationFilter'
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeFilter']
    balance: 'BalanceRelationFilter'
    transactions: 'TransactionListRelationFilter'
    deposits: 'DepositListRelationFilter'
    withdrawals: 'WithdrawalListRelationFilter'
    cryptoOrders: 'CryptoOrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive2', List['UserWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive2']
    OR: List['UserWhereInputRecursive2']
    NOT: List['UserWhereInputRecursive2']


class UserWhereInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    telegramId: Union[_int, 'types.BigIntFilter']
    username: Union[None, _str, 'types.StringFilter']
    firstName: Union[None, _str, 'types.StringFilter']
    lastName: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    whatsapp: Union[None, _str, 'types.StringFilter']
    latitude: Union[None, _float, 'types.FloatFilter']
    longitude: Union[None, _float, 'types.FloatFilter']
    pinHash: Union[None, _str, 'types.StringFilter']
    referralCode: Union[_str, 'types.StringFilter']
    referredById: Union[None, _str, 'types.StringFilter']
    referredBy: 'UserRelationFilter'
    referrals: 'UserListRelationFilter'
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeFilter']
    balance: 'BalanceRelationFilter'
    transactions: 'TransactionListRelationFilter'
    deposits: 'DepositListRelationFilter'
    withdrawals: 'WithdrawalListRelationFilter'
    cryptoOrders: 'CryptoOrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive3', List['UserWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive3']
    OR: List['UserWhereInputRecursive3']
    NOT: List['UserWhereInputRecursive3']


class UserWhereInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    telegramId: Union[_int, 'types.BigIntFilter']
    username: Union[None, _str, 'types.StringFilter']
    firstName: Union[None, _str, 'types.StringFilter']
    lastName: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    whatsapp: Union[None, _str, 'types.StringFilter']
    latitude: Union[None, _float, 'types.FloatFilter']
    longitude: Union[None, _float, 'types.FloatFilter']
    pinHash: Union[None, _str, 'types.StringFilter']
    referralCode: Union[_str, 'types.StringFilter']
    referredById: Union[None, _str, 'types.StringFilter']
    referredBy: 'UserRelationFilter'
    referrals: 'UserListRelationFilter'
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeFilter']
    balance: 'BalanceRelationFilter'
    transactions: 'TransactionListRelationFilter'
    deposits: 'DepositListRelationFilter'
    withdrawals: 'WithdrawalListRelationFilter'
    cryptoOrders: 'CryptoOrderListRelationFilter'

    # should be noted that AND and NOT should be Union['UserWhereInputRecursive4', List['UserWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInputRecursive4']
    OR: List['UserWhereInputRecursive4']
    NOT: List['UserWhereInputRecursive4']


class UserWhereInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    telegramId: Union[_int, 'types.BigIntFilter']
    username: Union[None, _str, 'types.StringFilter']
    firstName: Union[None, _str, 'types.StringFilter']
    lastName: Union[None, _str, 'types.StringFilter']
    email: Union[None, _str, 'types.StringFilter']
    whatsapp: Union[None, _str, 'types.StringFilter']
    latitude: Union[None, _float, 'types.FloatFilter']
    longitude: Union[None, _float, 'types.FloatFilter']
    pinHash: Union[None, _str, 'types.StringFilter']
    referralCode: Union[_str, 'types.StringFilter']
    referredById: Union[None, _str, 'types.StringFilter']
    referredBy: 'UserRelationFilter'
    referrals: 'UserListRelationFilter'
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeFilter']
    balance: 'BalanceRelationFilter'
    transactions: 'TransactionListRelationFilter'
    deposits: 'DepositListRelationFilter'
    withdrawals: 'WithdrawalListRelationFilter'
    cryptoOrders: 'CryptoOrderListRelationFilter'



# aggregate User types


    

class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    telegramId: Union[_int, 'types.BigIntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    whatsapp: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    pinHash: Union[_str, 'types.StringWithAggregatesFilter']
    referralCode: Union[_str, 'types.StringWithAggregatesFilter']
    referredById: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive1']


class UserScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    telegramId: Union[_int, 'types.BigIntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    whatsapp: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    pinHash: Union[_str, 'types.StringWithAggregatesFilter']
    referralCode: Union[_str, 'types.StringWithAggregatesFilter']
    referredById: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive2']


class UserScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    telegramId: Union[_int, 'types.BigIntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    whatsapp: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    pinHash: Union[_str, 'types.StringWithAggregatesFilter']
    referralCode: Union[_str, 'types.StringWithAggregatesFilter']
    referredById: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive3']


class UserScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    telegramId: Union[_int, 'types.BigIntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    whatsapp: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    pinHash: Union[_str, 'types.StringWithAggregatesFilter']
    referralCode: Union[_str, 'types.StringWithAggregatesFilter']
    referredById: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserScalarWhereWithAggregatesInputRecursive4']


class UserScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    telegramId: Union[_int, 'types.BigIntWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    whatsapp: Union[_str, 'types.StringWithAggregatesFilter']
    latitude: Union[_float, 'types.FloatWithAggregatesFilter']
    longitude: Union[_float, 'types.FloatWithAggregatesFilter']
    pinHash: Union[_str, 'types.StringWithAggregatesFilter']
    referralCode: Union[_str, 'types.StringWithAggregatesFilter']
    referredById: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.UserStatus'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    lastActiveAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    telegramId: _int
    username: _str
    firstName: _str
    lastName: _str
    email: _str
    whatsapp: _str
    latitude: _float
    longitude: _float
    pinHash: _str
    referralCode: _str
    referredById: _str
    status: 'enums.UserStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    lastActiveAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""
    telegramId: float
    latitude: float
    longitude: float


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""
    telegramId: _int
    latitude: _float
    longitude: _float


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    telegramId: _int
    username: _str
    firstName: _str
    lastName: _str
    email: _str
    whatsapp: _str
    latitude: _float
    longitude: _float
    pinHash: _str
    referralCode: _str
    referredById: _str
    status: 'enums.UserStatus'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    lastActiveAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    telegramId: bool
    username: bool
    firstName: bool
    lastName: bool
    email: bool
    whatsapp: bool
    latitude: bool
    longitude: bool
    pinHash: bool
    referralCode: bool
    referredById: bool
    status: bool
    createdAt: bool
    updatedAt: bool
    lastActiveAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    telegramId: bool
    username: bool
    firstName: bool
    lastName: bool
    email: bool
    whatsapp: bool
    latitude: bool
    longitude: bool
    pinHash: bool
    referralCode: bool
    referredById: bool
    status: bool
    createdAt: bool
    updatedAt: bool
    lastActiveAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""
    telegramId: bool
    latitude: bool
    longitude: bool


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'telegramId': bool,
        'username': bool,
        'firstName': bool,
        'lastName': bool,
        'email': bool,
        'whatsapp': bool,
        'latitude': bool,
        'longitude': bool,
        'pinHash': bool,
        'referralCode': bool,
        'referredById': bool,
        'status': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'lastActiveAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'telegramId': int,
        'username': int,
        'firstName': int,
        'lastName': int,
        'email': int,
        'whatsapp': int,
        'latitude': int,
        'longitude': int,
        'pinHash': int,
        'referralCode': int,
        'referredById': int,
        'status': int,
        'createdAt': int,
        'updatedAt': int,
        'lastActiveAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'telegramId',
    'username',
    'firstName',
    'lastName',
    'email',
    'whatsapp',
    'latitude',
    'longitude',
    'pinHash',
    'referralCode',
    'referredById',
    'referredBy',
    'referrals',
    'status',
    'createdAt',
    'updatedAt',
    'lastActiveAt',
    'balance',
    'transactions',
    'deposits',
    'withdrawals',
    'cryptoOrders',
]
UserScalarFieldKeys = Literal[
    'id',
    'telegramId',
    'username',
    'firstName',
    'lastName',
    'email',
    'whatsapp',
    'latitude',
    'longitude',
    'pinHash',
    'referralCode',
    'referredById',
    'status',
    'createdAt',
    'updatedAt',
    'lastActiveAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'referredBy',
        'referrals',
        'balance',
        'transactions',
        'deposits',
        'withdrawals',
        'cryptoOrders',
    ]

# Balance types

class BalanceOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Balance create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    amount: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BalanceCreateInput(BalanceOptionalCreateInput):
    """Required arguments to the Balance create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class BalanceOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Balance create method, without relations"""
    id: _str
    userId: _str
    amount: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BalanceCreateWithoutRelationsInput(BalanceOptionalCreateWithoutRelationsInput):
    """Required arguments to the Balance create method, without relations"""

class BalanceConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'BalanceCreateWithoutRelationsInput'
    where: 'BalanceWhereUniqueInput'

class BalanceCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'BalanceCreateWithoutRelationsInput'
    connect: 'BalanceWhereUniqueInput'
    connect_or_create: 'BalanceConnectOrCreateWithoutRelationsInput'


class BalanceCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['BalanceCreateWithoutRelationsInput', List['BalanceCreateWithoutRelationsInput']]
    connect: Union['BalanceWhereUniqueInput', List['BalanceWhereUniqueInput']]
    connect_or_create: Union['BalanceConnectOrCreateWithoutRelationsInput', List['BalanceConnectOrCreateWithoutRelationsInput']]

_BalanceWhereUnique_id_Input = TypedDict(
    '_BalanceWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_BalanceWhereUnique_userId_Input = TypedDict(
    '_BalanceWhereUnique_userId_Input',
    {
        'userId': '_str',
    },
    total=True
)

BalanceWhereUniqueInput = Union[
    '_BalanceWhereUnique_id_Input',
    '_BalanceWhereUnique_userId_Input',
]


class BalanceUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    amount: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BalanceUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    amount: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class BalanceUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['BalanceCreateWithoutRelationsInput']
    connect: List['BalanceWhereUniqueInput']
    connect_or_create: List['BalanceConnectOrCreateWithoutRelationsInput']
    set: List['BalanceWhereUniqueInput']
    disconnect: List['BalanceWhereUniqueInput']
    delete: List['BalanceWhereUniqueInput']

    # TODO
    # update: List['BalanceUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['BalanceUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['BalanceScalarWhereInput']
    # upsert: List['BalanceUpserteWithWhereUniqueWithoutRelationsInput']


class BalanceUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'BalanceCreateWithoutRelationsInput'
    connect: 'BalanceWhereUniqueInput'
    connect_or_create: 'BalanceConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'BalanceUpdateInput'
    # upsert: 'BalanceUpsertWithoutRelationsInput'


class BalanceUpsertInput(TypedDict):
    create: 'BalanceCreateInput'
    update: 'BalanceUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Balance_id_OrderByInput = TypedDict(
    '_Balance_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Balance_userId_OrderByInput = TypedDict(
    '_Balance_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Balance_amount_OrderByInput = TypedDict(
    '_Balance_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Balance_createdAt_OrderByInput = TypedDict(
    '_Balance_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Balance_updatedAt_OrderByInput = TypedDict(
    '_Balance_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Balance_RelevanceInner = TypedDict(
    '_Balance_RelevanceInner',
    {
        'fields': 'List[BalanceScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Balance_RelevanceOrderByInput = TypedDict(
    '_Balance_RelevanceOrderByInput',
    {
        '_relevance': '_Balance_RelevanceInner',
    },
    total=True
)

BalanceOrderByInput = Union[
    '_Balance_id_OrderByInput',
    '_Balance_userId_OrderByInput',
    '_Balance_amount_OrderByInput',
    '_Balance_createdAt_OrderByInput',
    '_Balance_updatedAt_OrderByInput',
    '_Balance_RelevanceOrderByInput',
]



# recursive Balance types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

BalanceRelationFilter = TypedDict(
    'BalanceRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class BalanceListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class BalanceInclude(TypedDict, total=False):
    """Balance relational arguments"""
    user: Union[bool, 'UserArgsFromBalance']


    

class UserIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    referredBy: Union[bool, 'UserArgsFromBalanceRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromBalanceRecursive1']
    balance: Union[bool, 'BalanceArgsFromBalanceRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromBalanceRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromBalanceRecursive1']


class UserIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    referredBy: Union[bool, 'UserArgsFromBalanceRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromBalanceRecursive2']
    balance: Union[bool, 'BalanceArgsFromBalanceRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromBalanceRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromBalanceRecursive2']


class UserIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    referredBy: Union[bool, 'UserArgsFromBalanceRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromBalanceRecursive3']
    balance: Union[bool, 'BalanceArgsFromBalanceRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromBalanceRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromBalanceRecursive3']


class UserIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    referredBy: Union[bool, 'UserArgsFromBalanceRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromBalanceRecursive4']
    balance: Union[bool, 'BalanceArgsFromBalanceRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromBalanceRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromBalanceRecursive4']


class UserIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class UserArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyUserArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive1']


class BalanceIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive2']


class BalanceIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive3']


class BalanceIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive4']


class BalanceIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class BalanceArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyBalanceArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive1']


class TransactionIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive2']


class TransactionIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive3']


class TransactionIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive4']


class TransactionIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class TransactionArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyTransactionArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive1']


class DepositIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive2']


class DepositIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive3']


class DepositIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive4']


class DepositIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class DepositArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyDepositArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive1']


class WithdrawalIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive2']


class WithdrawalIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive3']


class WithdrawalIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromBalanceRecursive4']


class WithdrawalIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class WithdrawalArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyWithdrawalArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive1']


class CryptoOrderIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive2']


class CryptoOrderIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive3']


class CryptoOrderIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    user: Union[bool, 'UserArgsFromBalanceRecursive4']


class CryptoOrderIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class CryptoOrderArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyCryptoOrderArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""


class SettingIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""


class SettingIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""


class SettingIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""


class SettingIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class SettingArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManySettingArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""


class CoinSettingIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""


class CoinSettingIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""


class CoinSettingIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""


class CoinSettingIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class CoinSettingArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyCoinSettingArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""


class PaymentMethodIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""


class PaymentMethodIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""


class PaymentMethodIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""


class PaymentMethodIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class PaymentMethodArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyPaymentMethodArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive1']


class AdminIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive2']


class AdminIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive3']


class AdminIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromBalanceRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromBalanceRecursive4']


class AdminIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class AdminArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyAdminArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromBalance(TypedDict, total=False):
    """Relational arguments for Balance"""


class ReferralSettingIncludeFromBalanceRecursive1(TypedDict, total=False):
    """Relational arguments for Balance"""


class ReferralSettingIncludeFromBalanceRecursive2(TypedDict, total=False):
    """Relational arguments for Balance"""


class ReferralSettingIncludeFromBalanceRecursive3(TypedDict, total=False):
    """Relational arguments for Balance"""


class ReferralSettingIncludeFromBalanceRecursive4(TypedDict, total=False):
    """Relational arguments for Balance"""

    

class ReferralSettingArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    
    

class FindManyReferralSettingArgsFromBalance(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromBalanceRecursive1(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromBalanceRecursive2(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromBalanceRecursive3(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromBalanceRecursive4(TypedDict, total=False):
    """Arguments for Balance"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyBalanceArgs = FindManyBalanceArgsFromBalance
FindFirstBalanceArgs = FindManyBalanceArgsFromBalance


    

class BalanceWhereInput(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BalanceWhereInputRecursive1', List['BalanceWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['BalanceWhereInputRecursive1']
    OR: List['BalanceWhereInputRecursive1']
    NOT: List['BalanceWhereInputRecursive1']


class BalanceWhereInputRecursive1(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BalanceWhereInputRecursive2', List['BalanceWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['BalanceWhereInputRecursive2']
    OR: List['BalanceWhereInputRecursive2']
    NOT: List['BalanceWhereInputRecursive2']


class BalanceWhereInputRecursive2(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BalanceWhereInputRecursive3', List['BalanceWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['BalanceWhereInputRecursive3']
    OR: List['BalanceWhereInputRecursive3']
    NOT: List['BalanceWhereInputRecursive3']


class BalanceWhereInputRecursive3(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['BalanceWhereInputRecursive4', List['BalanceWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['BalanceWhereInputRecursive4']
    OR: List['BalanceWhereInputRecursive4']
    NOT: List['BalanceWhereInputRecursive4']


class BalanceWhereInputRecursive4(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Balance types


    

class BalanceScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BalanceScalarWhereWithAggregatesInputRecursive1']
    OR: List['BalanceScalarWhereWithAggregatesInputRecursive1']
    NOT: List['BalanceScalarWhereWithAggregatesInputRecursive1']


class BalanceScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BalanceScalarWhereWithAggregatesInputRecursive2']
    OR: List['BalanceScalarWhereWithAggregatesInputRecursive2']
    NOT: List['BalanceScalarWhereWithAggregatesInputRecursive2']


class BalanceScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BalanceScalarWhereWithAggregatesInputRecursive3']
    OR: List['BalanceScalarWhereWithAggregatesInputRecursive3']
    NOT: List['BalanceScalarWhereWithAggregatesInputRecursive3']


class BalanceScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['BalanceScalarWhereWithAggregatesInputRecursive4']
    OR: List['BalanceScalarWhereWithAggregatesInputRecursive4']
    NOT: List['BalanceScalarWhereWithAggregatesInputRecursive4']


class BalanceScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Balance arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class BalanceGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    amount: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'BalanceSumAggregateOutput'
    _avg: 'BalanceAvgAggregateOutput'
    _min: 'BalanceMinAggregateOutput'
    _max: 'BalanceMaxAggregateOutput'
    _count: 'BalanceCountAggregateOutput'


class BalanceAvgAggregateOutput(TypedDict, total=False):
    """Balance output for aggregating averages"""


class BalanceSumAggregateOutput(TypedDict, total=False):
    """Balance output for aggregating sums"""


class BalanceScalarAggregateOutput(TypedDict, total=False):
    """Balance output including scalar fields"""
    id: _str
    userId: _str
    amount: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


BalanceMinAggregateOutput = BalanceScalarAggregateOutput
BalanceMaxAggregateOutput = BalanceScalarAggregateOutput


class BalanceMaxAggregateInput(TypedDict, total=False):
    """Balance input for aggregating by max"""
    id: bool
    userId: bool
    amount: bool
    createdAt: bool
    updatedAt: bool


class BalanceMinAggregateInput(TypedDict, total=False):
    """Balance input for aggregating by min"""
    id: bool
    userId: bool
    amount: bool
    createdAt: bool
    updatedAt: bool


class BalanceNumberAggregateInput(TypedDict, total=False):
    """Balance input for aggregating numbers"""


BalanceAvgAggregateInput = BalanceNumberAggregateInput
BalanceSumAggregateInput = BalanceNumberAggregateInput


BalanceCountAggregateInput = TypedDict(
    'BalanceCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'amount': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

BalanceCountAggregateOutput = TypedDict(
    'BalanceCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'amount': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


BalanceKeys = Literal[
    'id',
    'userId',
    'user',
    'amount',
    'createdAt',
    'updatedAt',
]
BalanceScalarFieldKeys = Literal[
    'id',
    'userId',
    'amount',
    'createdAt',
    'updatedAt',
]
BalanceScalarFieldKeysT = TypeVar('BalanceScalarFieldKeysT', bound=BalanceScalarFieldKeys)

BalanceRelationalFieldKeys = Literal[
        'user',
    ]

# Transaction types

class TransactionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Transaction create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    description: Optional[_str]
    status: 'enums.TransactionStatus'
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TransactionCreateInput(TransactionOptionalCreateInput):
    """Required arguments to the Transaction create method"""
    type: 'enums.TransactionType'
    amount: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TransactionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Transaction create method, without relations"""
    id: _str
    userId: _str
    description: Optional[_str]
    status: 'enums.TransactionStatus'
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TransactionCreateWithoutRelationsInput(TransactionOptionalCreateWithoutRelationsInput):
    """Required arguments to the Transaction create method, without relations"""
    type: 'enums.TransactionType'
    amount: decimal.Decimal

class TransactionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TransactionCreateWithoutRelationsInput'
    where: 'TransactionWhereUniqueInput'

class TransactionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TransactionCreateWithoutRelationsInput'
    connect: 'TransactionWhereUniqueInput'
    connect_or_create: 'TransactionConnectOrCreateWithoutRelationsInput'


class TransactionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TransactionCreateWithoutRelationsInput', List['TransactionCreateWithoutRelationsInput']]
    connect: Union['TransactionWhereUniqueInput', List['TransactionWhereUniqueInput']]
    connect_or_create: Union['TransactionConnectOrCreateWithoutRelationsInput', List['TransactionConnectOrCreateWithoutRelationsInput']]

_TransactionWhereUnique_id_Input = TypedDict(
    '_TransactionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

TransactionWhereUniqueInput = _TransactionWhereUnique_id_Input


class TransactionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    type: 'enums.TransactionType'
    amount: decimal.Decimal
    description: Optional[_str]
    status: 'enums.TransactionStatus'
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TransactionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: 'enums.TransactionType'
    amount: decimal.Decimal
    description: Optional[_str]
    status: 'enums.TransactionStatus'
    metadata: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class TransactionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TransactionCreateWithoutRelationsInput']
    connect: List['TransactionWhereUniqueInput']
    connect_or_create: List['TransactionConnectOrCreateWithoutRelationsInput']
    set: List['TransactionWhereUniqueInput']
    disconnect: List['TransactionWhereUniqueInput']
    delete: List['TransactionWhereUniqueInput']

    # TODO
    # update: List['TransactionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TransactionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TransactionScalarWhereInput']
    # upsert: List['TransactionUpserteWithWhereUniqueWithoutRelationsInput']


class TransactionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TransactionCreateWithoutRelationsInput'
    connect: 'TransactionWhereUniqueInput'
    connect_or_create: 'TransactionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TransactionUpdateInput'
    # upsert: 'TransactionUpsertWithoutRelationsInput'


class TransactionUpsertInput(TypedDict):
    create: 'TransactionCreateInput'
    update: 'TransactionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Transaction_id_OrderByInput = TypedDict(
    '_Transaction_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Transaction_userId_OrderByInput = TypedDict(
    '_Transaction_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Transaction_type_OrderByInput = TypedDict(
    '_Transaction_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Transaction_amount_OrderByInput = TypedDict(
    '_Transaction_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Transaction_description_OrderByInput = TypedDict(
    '_Transaction_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Transaction_status_OrderByInput = TypedDict(
    '_Transaction_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Transaction_metadata_OrderByInput = TypedDict(
    '_Transaction_metadata_OrderByInput',
    {
        'metadata': 'SortOrder',
    },
    total=True
)

_Transaction_createdAt_OrderByInput = TypedDict(
    '_Transaction_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Transaction_updatedAt_OrderByInput = TypedDict(
    '_Transaction_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Transaction_RelevanceInner = TypedDict(
    '_Transaction_RelevanceInner',
    {
        'fields': 'List[TransactionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Transaction_RelevanceOrderByInput = TypedDict(
    '_Transaction_RelevanceOrderByInput',
    {
        '_relevance': '_Transaction_RelevanceInner',
    },
    total=True
)

TransactionOrderByInput = Union[
    '_Transaction_id_OrderByInput',
    '_Transaction_userId_OrderByInput',
    '_Transaction_type_OrderByInput',
    '_Transaction_amount_OrderByInput',
    '_Transaction_description_OrderByInput',
    '_Transaction_status_OrderByInput',
    '_Transaction_metadata_OrderByInput',
    '_Transaction_createdAt_OrderByInput',
    '_Transaction_updatedAt_OrderByInput',
    '_Transaction_RelevanceOrderByInput',
]



# recursive Transaction types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

TransactionRelationFilter = TypedDict(
    'TransactionRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class TransactionListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class TransactionInclude(TypedDict, total=False):
    """Transaction relational arguments"""
    user: Union[bool, 'UserArgsFromTransaction']


    

class UserIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    referredBy: Union[bool, 'UserArgsFromTransactionRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromTransactionRecursive1']
    balance: Union[bool, 'BalanceArgsFromTransactionRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromTransactionRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromTransactionRecursive1']


class UserIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    referredBy: Union[bool, 'UserArgsFromTransactionRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromTransactionRecursive2']
    balance: Union[bool, 'BalanceArgsFromTransactionRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromTransactionRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromTransactionRecursive2']


class UserIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    referredBy: Union[bool, 'UserArgsFromTransactionRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromTransactionRecursive3']
    balance: Union[bool, 'BalanceArgsFromTransactionRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromTransactionRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromTransactionRecursive3']


class UserIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    referredBy: Union[bool, 'UserArgsFromTransactionRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromTransactionRecursive4']
    balance: Union[bool, 'BalanceArgsFromTransactionRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromTransactionRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromTransactionRecursive4']


class UserIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class UserArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyUserArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive1']


class BalanceIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive2']


class BalanceIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive3']


class BalanceIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive4']


class BalanceIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class BalanceArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyBalanceArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive1']


class TransactionIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive2']


class TransactionIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive3']


class TransactionIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive4']


class TransactionIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class TransactionArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyTransactionArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive1']


class DepositIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive2']


class DepositIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive3']


class DepositIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive4']


class DepositIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class DepositArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyDepositArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive1']


class WithdrawalIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive2']


class WithdrawalIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive3']


class WithdrawalIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromTransactionRecursive4']


class WithdrawalIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class WithdrawalArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyWithdrawalArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive1']


class CryptoOrderIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive2']


class CryptoOrderIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive3']


class CryptoOrderIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    user: Union[bool, 'UserArgsFromTransactionRecursive4']


class CryptoOrderIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class CryptoOrderArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyCryptoOrderArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""


class SettingIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""


class SettingIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""


class SettingIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""


class SettingIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class SettingArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManySettingArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""


class CoinSettingIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""


class CoinSettingIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""


class CoinSettingIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""


class CoinSettingIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class CoinSettingArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyCoinSettingArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""


class PaymentMethodIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""


class PaymentMethodIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""


class PaymentMethodIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""


class PaymentMethodIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class PaymentMethodArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyPaymentMethodArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive1']


class AdminIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive2']


class AdminIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive3']


class AdminIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromTransactionRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromTransactionRecursive4']


class AdminIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class AdminArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyAdminArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromTransaction(TypedDict, total=False):
    """Relational arguments for Transaction"""


class ReferralSettingIncludeFromTransactionRecursive1(TypedDict, total=False):
    """Relational arguments for Transaction"""


class ReferralSettingIncludeFromTransactionRecursive2(TypedDict, total=False):
    """Relational arguments for Transaction"""


class ReferralSettingIncludeFromTransactionRecursive3(TypedDict, total=False):
    """Relational arguments for Transaction"""


class ReferralSettingIncludeFromTransactionRecursive4(TypedDict, total=False):
    """Relational arguments for Transaction"""

    

class ReferralSettingArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    
    

class FindManyReferralSettingArgsFromTransaction(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromTransactionRecursive1(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromTransactionRecursive2(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromTransactionRecursive3(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromTransactionRecursive4(TypedDict, total=False):
    """Arguments for Transaction"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyTransactionArgs = FindManyTransactionArgsFromTransaction
FindFirstTransactionArgs = FindManyTransactionArgsFromTransaction


    

class TransactionWhereInput(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    description: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TransactionWhereInputRecursive1', List['TransactionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['TransactionWhereInputRecursive1']
    OR: List['TransactionWhereInputRecursive1']
    NOT: List['TransactionWhereInputRecursive1']


class TransactionWhereInputRecursive1(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    description: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TransactionWhereInputRecursive2', List['TransactionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['TransactionWhereInputRecursive2']
    OR: List['TransactionWhereInputRecursive2']
    NOT: List['TransactionWhereInputRecursive2']


class TransactionWhereInputRecursive2(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    description: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TransactionWhereInputRecursive3', List['TransactionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['TransactionWhereInputRecursive3']
    OR: List['TransactionWhereInputRecursive3']
    NOT: List['TransactionWhereInputRecursive3']


class TransactionWhereInputRecursive3(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    description: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TransactionWhereInputRecursive4', List['TransactionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['TransactionWhereInputRecursive4']
    OR: List['TransactionWhereInputRecursive4']
    NOT: List['TransactionWhereInputRecursive4']


class TransactionWhereInputRecursive4(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    description: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    metadata: Union[None, 'fields.Json', 'types.JsonFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Transaction types


    

class TransactionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TransactionScalarWhereWithAggregatesInputRecursive1']
    OR: List['TransactionScalarWhereWithAggregatesInputRecursive1']
    NOT: List['TransactionScalarWhereWithAggregatesInputRecursive1']


class TransactionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TransactionScalarWhereWithAggregatesInputRecursive2']
    OR: List['TransactionScalarWhereWithAggregatesInputRecursive2']
    NOT: List['TransactionScalarWhereWithAggregatesInputRecursive2']


class TransactionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TransactionScalarWhereWithAggregatesInputRecursive3']
    OR: List['TransactionScalarWhereWithAggregatesInputRecursive3']
    NOT: List['TransactionScalarWhereWithAggregatesInputRecursive3']


class TransactionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TransactionScalarWhereWithAggregatesInputRecursive4']
    OR: List['TransactionScalarWhereWithAggregatesInputRecursive4']
    NOT: List['TransactionScalarWhereWithAggregatesInputRecursive4']


class TransactionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Transaction arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.TransactionType'
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    metadata: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class TransactionGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    type: 'enums.TransactionType'
    amount: decimal.Decimal
    description: _str
    status: 'enums.TransactionStatus'
    metadata: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'TransactionSumAggregateOutput'
    _avg: 'TransactionAvgAggregateOutput'
    _min: 'TransactionMinAggregateOutput'
    _max: 'TransactionMaxAggregateOutput'
    _count: 'TransactionCountAggregateOutput'


class TransactionAvgAggregateOutput(TypedDict, total=False):
    """Transaction output for aggregating averages"""


class TransactionSumAggregateOutput(TypedDict, total=False):
    """Transaction output for aggregating sums"""


class TransactionScalarAggregateOutput(TypedDict, total=False):
    """Transaction output including scalar fields"""
    id: _str
    userId: _str
    type: 'enums.TransactionType'
    amount: decimal.Decimal
    description: _str
    status: 'enums.TransactionStatus'
    metadata: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


TransactionMinAggregateOutput = TransactionScalarAggregateOutput
TransactionMaxAggregateOutput = TransactionScalarAggregateOutput


class TransactionMaxAggregateInput(TypedDict, total=False):
    """Transaction input for aggregating by max"""
    id: bool
    userId: bool
    type: bool
    amount: bool
    description: bool
    status: bool
    metadata: bool
    createdAt: bool
    updatedAt: bool


class TransactionMinAggregateInput(TypedDict, total=False):
    """Transaction input for aggregating by min"""
    id: bool
    userId: bool
    type: bool
    amount: bool
    description: bool
    status: bool
    metadata: bool
    createdAt: bool
    updatedAt: bool


class TransactionNumberAggregateInput(TypedDict, total=False):
    """Transaction input for aggregating numbers"""


TransactionAvgAggregateInput = TransactionNumberAggregateInput
TransactionSumAggregateInput = TransactionNumberAggregateInput


TransactionCountAggregateInput = TypedDict(
    'TransactionCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'type': bool,
        'amount': bool,
        'description': bool,
        'status': bool,
        'metadata': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

TransactionCountAggregateOutput = TypedDict(
    'TransactionCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'type': int,
        'amount': int,
        'description': int,
        'status': int,
        'metadata': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


TransactionKeys = Literal[
    'id',
    'userId',
    'user',
    'type',
    'amount',
    'description',
    'status',
    'metadata',
    'createdAt',
    'updatedAt',
]
TransactionScalarFieldKeys = Literal[
    'id',
    'userId',
    'type',
    'amount',
    'description',
    'status',
    'metadata',
    'createdAt',
    'updatedAt',
]
TransactionScalarFieldKeysT = TypeVar('TransactionScalarFieldKeysT', bound=TransactionScalarFieldKeys)

TransactionRelationalFieldKeys = Literal[
        'user',
    ]

# Deposit types

class DepositOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Deposit create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    proofImage: Optional[_str]
    cryptobotInvoiceId: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    approvedById: Optional[_str]
    approvedBy: 'AdminCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DepositCreateInput(DepositOptionalCreateInput):
    """Required arguments to the Deposit create method"""
    amount: decimal.Decimal
    paymentMethod: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class DepositOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Deposit create method, without relations"""
    id: _str
    userId: _str
    proofImage: Optional[_str]
    cryptobotInvoiceId: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    approvedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DepositCreateWithoutRelationsInput(DepositOptionalCreateWithoutRelationsInput):
    """Required arguments to the Deposit create method, without relations"""
    amount: decimal.Decimal
    paymentMethod: _str

class DepositConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'DepositCreateWithoutRelationsInput'
    where: 'DepositWhereUniqueInput'

class DepositCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'DepositCreateWithoutRelationsInput'
    connect: 'DepositWhereUniqueInput'
    connect_or_create: 'DepositConnectOrCreateWithoutRelationsInput'


class DepositCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['DepositCreateWithoutRelationsInput', List['DepositCreateWithoutRelationsInput']]
    connect: Union['DepositWhereUniqueInput', List['DepositWhereUniqueInput']]
    connect_or_create: Union['DepositConnectOrCreateWithoutRelationsInput', List['DepositConnectOrCreateWithoutRelationsInput']]

_DepositWhereUnique_id_Input = TypedDict(
    '_DepositWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

DepositWhereUniqueInput = _DepositWhereUnique_id_Input


class DepositUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    amount: decimal.Decimal
    paymentMethod: _str
    proofImage: Optional[_str]
    cryptobotInvoiceId: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    approvedBy: 'AdminUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DepositUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    amount: decimal.Decimal
    paymentMethod: _str
    proofImage: Optional[_str]
    cryptobotInvoiceId: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class DepositUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['DepositCreateWithoutRelationsInput']
    connect: List['DepositWhereUniqueInput']
    connect_or_create: List['DepositConnectOrCreateWithoutRelationsInput']
    set: List['DepositWhereUniqueInput']
    disconnect: List['DepositWhereUniqueInput']
    delete: List['DepositWhereUniqueInput']

    # TODO
    # update: List['DepositUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['DepositUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['DepositScalarWhereInput']
    # upsert: List['DepositUpserteWithWhereUniqueWithoutRelationsInput']


class DepositUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'DepositCreateWithoutRelationsInput'
    connect: 'DepositWhereUniqueInput'
    connect_or_create: 'DepositConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'DepositUpdateInput'
    # upsert: 'DepositUpsertWithoutRelationsInput'


class DepositUpsertInput(TypedDict):
    create: 'DepositCreateInput'
    update: 'DepositUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Deposit_id_OrderByInput = TypedDict(
    '_Deposit_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Deposit_userId_OrderByInput = TypedDict(
    '_Deposit_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Deposit_amount_OrderByInput = TypedDict(
    '_Deposit_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Deposit_paymentMethod_OrderByInput = TypedDict(
    '_Deposit_paymentMethod_OrderByInput',
    {
        'paymentMethod': 'SortOrder',
    },
    total=True
)

_Deposit_proofImage_OrderByInput = TypedDict(
    '_Deposit_proofImage_OrderByInput',
    {
        'proofImage': 'SortOrder',
    },
    total=True
)

_Deposit_cryptobotInvoiceId_OrderByInput = TypedDict(
    '_Deposit_cryptobotInvoiceId_OrderByInput',
    {
        'cryptobotInvoiceId': 'SortOrder',
    },
    total=True
)

_Deposit_status_OrderByInput = TypedDict(
    '_Deposit_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Deposit_adminNote_OrderByInput = TypedDict(
    '_Deposit_adminNote_OrderByInput',
    {
        'adminNote': 'SortOrder',
    },
    total=True
)

_Deposit_approvedById_OrderByInput = TypedDict(
    '_Deposit_approvedById_OrderByInput',
    {
        'approvedById': 'SortOrder',
    },
    total=True
)

_Deposit_createdAt_OrderByInput = TypedDict(
    '_Deposit_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Deposit_updatedAt_OrderByInput = TypedDict(
    '_Deposit_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Deposit_RelevanceInner = TypedDict(
    '_Deposit_RelevanceInner',
    {
        'fields': 'List[DepositScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Deposit_RelevanceOrderByInput = TypedDict(
    '_Deposit_RelevanceOrderByInput',
    {
        '_relevance': '_Deposit_RelevanceInner',
    },
    total=True
)

DepositOrderByInput = Union[
    '_Deposit_id_OrderByInput',
    '_Deposit_userId_OrderByInput',
    '_Deposit_amount_OrderByInput',
    '_Deposit_paymentMethod_OrderByInput',
    '_Deposit_proofImage_OrderByInput',
    '_Deposit_cryptobotInvoiceId_OrderByInput',
    '_Deposit_status_OrderByInput',
    '_Deposit_adminNote_OrderByInput',
    '_Deposit_approvedById_OrderByInput',
    '_Deposit_createdAt_OrderByInput',
    '_Deposit_updatedAt_OrderByInput',
    '_Deposit_RelevanceOrderByInput',
]



# recursive Deposit types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

DepositRelationFilter = TypedDict(
    'DepositRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class DepositListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class DepositInclude(TypedDict, total=False):
    """Deposit relational arguments"""
    user: Union[bool, 'UserArgsFromDeposit']
    approvedBy: Union[bool, 'AdminArgsFromDeposit']


    

class UserIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    referredBy: Union[bool, 'UserArgsFromDepositRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromDepositRecursive1']
    balance: Union[bool, 'BalanceArgsFromDepositRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromDepositRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromDepositRecursive1']


class UserIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    referredBy: Union[bool, 'UserArgsFromDepositRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromDepositRecursive2']
    balance: Union[bool, 'BalanceArgsFromDepositRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromDepositRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromDepositRecursive2']


class UserIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    referredBy: Union[bool, 'UserArgsFromDepositRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromDepositRecursive3']
    balance: Union[bool, 'BalanceArgsFromDepositRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromDepositRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromDepositRecursive3']


class UserIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    referredBy: Union[bool, 'UserArgsFromDepositRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromDepositRecursive4']
    balance: Union[bool, 'BalanceArgsFromDepositRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromDepositRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromDepositRecursive4']


class UserIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class UserArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyUserArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive1']


class BalanceIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive2']


class BalanceIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive3']


class BalanceIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive4']


class BalanceIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class BalanceArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyBalanceArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive1']


class TransactionIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive2']


class TransactionIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive3']


class TransactionIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive4']


class TransactionIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class TransactionArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyTransactionArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive1']


class DepositIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive2']


class DepositIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive3']


class DepositIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive4']


class DepositIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class DepositArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyDepositArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive1']


class WithdrawalIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive2']


class WithdrawalIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive3']


class WithdrawalIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromDepositRecursive4']


class WithdrawalIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class WithdrawalArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyWithdrawalArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive1']


class CryptoOrderIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive2']


class CryptoOrderIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive3']


class CryptoOrderIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    user: Union[bool, 'UserArgsFromDepositRecursive4']


class CryptoOrderIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class CryptoOrderArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyCryptoOrderArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""


class SettingIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""


class SettingIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""


class SettingIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""


class SettingIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class SettingArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManySettingArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""


class CoinSettingIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""


class CoinSettingIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""


class CoinSettingIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""


class CoinSettingIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class CoinSettingArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyCoinSettingArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""


class PaymentMethodIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""


class PaymentMethodIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""


class PaymentMethodIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""


class PaymentMethodIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class PaymentMethodArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyPaymentMethodArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive1']


class AdminIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive2']


class AdminIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive3']


class AdminIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromDepositRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromDepositRecursive4']


class AdminIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class AdminArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyAdminArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromDeposit(TypedDict, total=False):
    """Relational arguments for Deposit"""


class ReferralSettingIncludeFromDepositRecursive1(TypedDict, total=False):
    """Relational arguments for Deposit"""


class ReferralSettingIncludeFromDepositRecursive2(TypedDict, total=False):
    """Relational arguments for Deposit"""


class ReferralSettingIncludeFromDepositRecursive3(TypedDict, total=False):
    """Relational arguments for Deposit"""


class ReferralSettingIncludeFromDepositRecursive4(TypedDict, total=False):
    """Relational arguments for Deposit"""

    

class ReferralSettingArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    
    

class FindManyReferralSettingArgsFromDeposit(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromDepositRecursive1(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromDepositRecursive2(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromDepositRecursive3(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromDepositRecursive4(TypedDict, total=False):
    """Arguments for Deposit"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyDepositArgs = FindManyDepositArgsFromDeposit
FindFirstDepositArgs = FindManyDepositArgsFromDeposit


    

class DepositWhereInput(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    paymentMethod: Union[_str, 'types.StringFilter']
    proofImage: Union[None, _str, 'types.StringFilter']
    cryptobotInvoiceId: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DepositWhereInputRecursive1', List['DepositWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['DepositWhereInputRecursive1']
    OR: List['DepositWhereInputRecursive1']
    NOT: List['DepositWhereInputRecursive1']


class DepositWhereInputRecursive1(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    paymentMethod: Union[_str, 'types.StringFilter']
    proofImage: Union[None, _str, 'types.StringFilter']
    cryptobotInvoiceId: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DepositWhereInputRecursive2', List['DepositWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['DepositWhereInputRecursive2']
    OR: List['DepositWhereInputRecursive2']
    NOT: List['DepositWhereInputRecursive2']


class DepositWhereInputRecursive2(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    paymentMethod: Union[_str, 'types.StringFilter']
    proofImage: Union[None, _str, 'types.StringFilter']
    cryptobotInvoiceId: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DepositWhereInputRecursive3', List['DepositWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['DepositWhereInputRecursive3']
    OR: List['DepositWhereInputRecursive3']
    NOT: List['DepositWhereInputRecursive3']


class DepositWhereInputRecursive3(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    paymentMethod: Union[_str, 'types.StringFilter']
    proofImage: Union[None, _str, 'types.StringFilter']
    cryptobotInvoiceId: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['DepositWhereInputRecursive4', List['DepositWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['DepositWhereInputRecursive4']
    OR: List['DepositWhereInputRecursive4']
    NOT: List['DepositWhereInputRecursive4']


class DepositWhereInputRecursive4(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    paymentMethod: Union[_str, 'types.StringFilter']
    proofImage: Union[None, _str, 'types.StringFilter']
    cryptobotInvoiceId: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Deposit types


    

class DepositScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    paymentMethod: Union[_str, 'types.StringWithAggregatesFilter']
    proofImage: Union[_str, 'types.StringWithAggregatesFilter']
    cryptobotInvoiceId: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DepositScalarWhereWithAggregatesInputRecursive1']
    OR: List['DepositScalarWhereWithAggregatesInputRecursive1']
    NOT: List['DepositScalarWhereWithAggregatesInputRecursive1']


class DepositScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    paymentMethod: Union[_str, 'types.StringWithAggregatesFilter']
    proofImage: Union[_str, 'types.StringWithAggregatesFilter']
    cryptobotInvoiceId: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DepositScalarWhereWithAggregatesInputRecursive2']
    OR: List['DepositScalarWhereWithAggregatesInputRecursive2']
    NOT: List['DepositScalarWhereWithAggregatesInputRecursive2']


class DepositScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    paymentMethod: Union[_str, 'types.StringWithAggregatesFilter']
    proofImage: Union[_str, 'types.StringWithAggregatesFilter']
    cryptobotInvoiceId: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DepositScalarWhereWithAggregatesInputRecursive3']
    OR: List['DepositScalarWhereWithAggregatesInputRecursive3']
    NOT: List['DepositScalarWhereWithAggregatesInputRecursive3']


class DepositScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    paymentMethod: Union[_str, 'types.StringWithAggregatesFilter']
    proofImage: Union[_str, 'types.StringWithAggregatesFilter']
    cryptobotInvoiceId: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['DepositScalarWhereWithAggregatesInputRecursive4']
    OR: List['DepositScalarWhereWithAggregatesInputRecursive4']
    NOT: List['DepositScalarWhereWithAggregatesInputRecursive4']


class DepositScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Deposit arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    paymentMethod: Union[_str, 'types.StringWithAggregatesFilter']
    proofImage: Union[_str, 'types.StringWithAggregatesFilter']
    cryptobotInvoiceId: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class DepositGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    amount: decimal.Decimal
    paymentMethod: _str
    proofImage: _str
    cryptobotInvoiceId: _str
    status: 'enums.TransactionStatus'
    adminNote: _str
    approvedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'DepositSumAggregateOutput'
    _avg: 'DepositAvgAggregateOutput'
    _min: 'DepositMinAggregateOutput'
    _max: 'DepositMaxAggregateOutput'
    _count: 'DepositCountAggregateOutput'


class DepositAvgAggregateOutput(TypedDict, total=False):
    """Deposit output for aggregating averages"""


class DepositSumAggregateOutput(TypedDict, total=False):
    """Deposit output for aggregating sums"""


class DepositScalarAggregateOutput(TypedDict, total=False):
    """Deposit output including scalar fields"""
    id: _str
    userId: _str
    amount: decimal.Decimal
    paymentMethod: _str
    proofImage: _str
    cryptobotInvoiceId: _str
    status: 'enums.TransactionStatus'
    adminNote: _str
    approvedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


DepositMinAggregateOutput = DepositScalarAggregateOutput
DepositMaxAggregateOutput = DepositScalarAggregateOutput


class DepositMaxAggregateInput(TypedDict, total=False):
    """Deposit input for aggregating by max"""
    id: bool
    userId: bool
    amount: bool
    paymentMethod: bool
    proofImage: bool
    cryptobotInvoiceId: bool
    status: bool
    adminNote: bool
    approvedById: bool
    createdAt: bool
    updatedAt: bool


class DepositMinAggregateInput(TypedDict, total=False):
    """Deposit input for aggregating by min"""
    id: bool
    userId: bool
    amount: bool
    paymentMethod: bool
    proofImage: bool
    cryptobotInvoiceId: bool
    status: bool
    adminNote: bool
    approvedById: bool
    createdAt: bool
    updatedAt: bool


class DepositNumberAggregateInput(TypedDict, total=False):
    """Deposit input for aggregating numbers"""


DepositAvgAggregateInput = DepositNumberAggregateInput
DepositSumAggregateInput = DepositNumberAggregateInput


DepositCountAggregateInput = TypedDict(
    'DepositCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'amount': bool,
        'paymentMethod': bool,
        'proofImage': bool,
        'cryptobotInvoiceId': bool,
        'status': bool,
        'adminNote': bool,
        'approvedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

DepositCountAggregateOutput = TypedDict(
    'DepositCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'amount': int,
        'paymentMethod': int,
        'proofImage': int,
        'cryptobotInvoiceId': int,
        'status': int,
        'adminNote': int,
        'approvedById': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


DepositKeys = Literal[
    'id',
    'userId',
    'user',
    'amount',
    'paymentMethod',
    'proofImage',
    'cryptobotInvoiceId',
    'status',
    'adminNote',
    'approvedById',
    'approvedBy',
    'createdAt',
    'updatedAt',
]
DepositScalarFieldKeys = Literal[
    'id',
    'userId',
    'amount',
    'paymentMethod',
    'proofImage',
    'cryptobotInvoiceId',
    'status',
    'adminNote',
    'approvedById',
    'createdAt',
    'updatedAt',
]
DepositScalarFieldKeysT = TypeVar('DepositScalarFieldKeysT', bound=DepositScalarFieldKeys)

DepositRelationalFieldKeys = Literal[
        'user',
        'approvedBy',
    ]

# Withdrawal types

class WithdrawalOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Withdrawal create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    bankName: Optional[_str]
    accountNumber: Optional[_str]
    accountName: Optional[_str]
    ewalletType: Optional[_str]
    ewalletNumber: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    approvedById: Optional[_str]
    approvedBy: 'AdminCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WithdrawalCreateInput(WithdrawalOptionalCreateInput):
    """Required arguments to the Withdrawal create method"""
    amount: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class WithdrawalOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Withdrawal create method, without relations"""
    id: _str
    userId: _str
    bankName: Optional[_str]
    accountNumber: Optional[_str]
    accountName: Optional[_str]
    ewalletType: Optional[_str]
    ewalletNumber: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    approvedById: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WithdrawalCreateWithoutRelationsInput(WithdrawalOptionalCreateWithoutRelationsInput):
    """Required arguments to the Withdrawal create method, without relations"""
    amount: decimal.Decimal

class WithdrawalConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'WithdrawalCreateWithoutRelationsInput'
    where: 'WithdrawalWhereUniqueInput'

class WithdrawalCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'WithdrawalCreateWithoutRelationsInput'
    connect: 'WithdrawalWhereUniqueInput'
    connect_or_create: 'WithdrawalConnectOrCreateWithoutRelationsInput'


class WithdrawalCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['WithdrawalCreateWithoutRelationsInput', List['WithdrawalCreateWithoutRelationsInput']]
    connect: Union['WithdrawalWhereUniqueInput', List['WithdrawalWhereUniqueInput']]
    connect_or_create: Union['WithdrawalConnectOrCreateWithoutRelationsInput', List['WithdrawalConnectOrCreateWithoutRelationsInput']]

_WithdrawalWhereUnique_id_Input = TypedDict(
    '_WithdrawalWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

WithdrawalWhereUniqueInput = _WithdrawalWhereUnique_id_Input


class WithdrawalUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    amount: decimal.Decimal
    bankName: Optional[_str]
    accountNumber: Optional[_str]
    accountName: Optional[_str]
    ewalletType: Optional[_str]
    ewalletNumber: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    approvedBy: 'AdminUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WithdrawalUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    amount: decimal.Decimal
    bankName: Optional[_str]
    accountNumber: Optional[_str]
    accountName: Optional[_str]
    ewalletType: Optional[_str]
    ewalletNumber: Optional[_str]
    status: 'enums.TransactionStatus'
    adminNote: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class WithdrawalUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['WithdrawalCreateWithoutRelationsInput']
    connect: List['WithdrawalWhereUniqueInput']
    connect_or_create: List['WithdrawalConnectOrCreateWithoutRelationsInput']
    set: List['WithdrawalWhereUniqueInput']
    disconnect: List['WithdrawalWhereUniqueInput']
    delete: List['WithdrawalWhereUniqueInput']

    # TODO
    # update: List['WithdrawalUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['WithdrawalUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['WithdrawalScalarWhereInput']
    # upsert: List['WithdrawalUpserteWithWhereUniqueWithoutRelationsInput']


class WithdrawalUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'WithdrawalCreateWithoutRelationsInput'
    connect: 'WithdrawalWhereUniqueInput'
    connect_or_create: 'WithdrawalConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'WithdrawalUpdateInput'
    # upsert: 'WithdrawalUpsertWithoutRelationsInput'


class WithdrawalUpsertInput(TypedDict):
    create: 'WithdrawalCreateInput'
    update: 'WithdrawalUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Withdrawal_id_OrderByInput = TypedDict(
    '_Withdrawal_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Withdrawal_userId_OrderByInput = TypedDict(
    '_Withdrawal_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Withdrawal_amount_OrderByInput = TypedDict(
    '_Withdrawal_amount_OrderByInput',
    {
        'amount': 'SortOrder',
    },
    total=True
)

_Withdrawal_bankName_OrderByInput = TypedDict(
    '_Withdrawal_bankName_OrderByInput',
    {
        'bankName': 'SortOrder',
    },
    total=True
)

_Withdrawal_accountNumber_OrderByInput = TypedDict(
    '_Withdrawal_accountNumber_OrderByInput',
    {
        'accountNumber': 'SortOrder',
    },
    total=True
)

_Withdrawal_accountName_OrderByInput = TypedDict(
    '_Withdrawal_accountName_OrderByInput',
    {
        'accountName': 'SortOrder',
    },
    total=True
)

_Withdrawal_ewalletType_OrderByInput = TypedDict(
    '_Withdrawal_ewalletType_OrderByInput',
    {
        'ewalletType': 'SortOrder',
    },
    total=True
)

_Withdrawal_ewalletNumber_OrderByInput = TypedDict(
    '_Withdrawal_ewalletNumber_OrderByInput',
    {
        'ewalletNumber': 'SortOrder',
    },
    total=True
)

_Withdrawal_status_OrderByInput = TypedDict(
    '_Withdrawal_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Withdrawal_adminNote_OrderByInput = TypedDict(
    '_Withdrawal_adminNote_OrderByInput',
    {
        'adminNote': 'SortOrder',
    },
    total=True
)

_Withdrawal_approvedById_OrderByInput = TypedDict(
    '_Withdrawal_approvedById_OrderByInput',
    {
        'approvedById': 'SortOrder',
    },
    total=True
)

_Withdrawal_createdAt_OrderByInput = TypedDict(
    '_Withdrawal_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Withdrawal_updatedAt_OrderByInput = TypedDict(
    '_Withdrawal_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Withdrawal_RelevanceInner = TypedDict(
    '_Withdrawal_RelevanceInner',
    {
        'fields': 'List[WithdrawalScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Withdrawal_RelevanceOrderByInput = TypedDict(
    '_Withdrawal_RelevanceOrderByInput',
    {
        '_relevance': '_Withdrawal_RelevanceInner',
    },
    total=True
)

WithdrawalOrderByInput = Union[
    '_Withdrawal_id_OrderByInput',
    '_Withdrawal_userId_OrderByInput',
    '_Withdrawal_amount_OrderByInput',
    '_Withdrawal_bankName_OrderByInput',
    '_Withdrawal_accountNumber_OrderByInput',
    '_Withdrawal_accountName_OrderByInput',
    '_Withdrawal_ewalletType_OrderByInput',
    '_Withdrawal_ewalletNumber_OrderByInput',
    '_Withdrawal_status_OrderByInput',
    '_Withdrawal_adminNote_OrderByInput',
    '_Withdrawal_approvedById_OrderByInput',
    '_Withdrawal_createdAt_OrderByInput',
    '_Withdrawal_updatedAt_OrderByInput',
    '_Withdrawal_RelevanceOrderByInput',
]



# recursive Withdrawal types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

WithdrawalRelationFilter = TypedDict(
    'WithdrawalRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class WithdrawalListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class WithdrawalInclude(TypedDict, total=False):
    """Withdrawal relational arguments"""
    user: Union[bool, 'UserArgsFromWithdrawal']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawal']


    

class UserIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    referredBy: Union[bool, 'UserArgsFromWithdrawalRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromWithdrawalRecursive1']
    balance: Union[bool, 'BalanceArgsFromWithdrawalRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromWithdrawalRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromWithdrawalRecursive1']


class UserIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    referredBy: Union[bool, 'UserArgsFromWithdrawalRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromWithdrawalRecursive2']
    balance: Union[bool, 'BalanceArgsFromWithdrawalRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromWithdrawalRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromWithdrawalRecursive2']


class UserIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    referredBy: Union[bool, 'UserArgsFromWithdrawalRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromWithdrawalRecursive3']
    balance: Union[bool, 'BalanceArgsFromWithdrawalRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromWithdrawalRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromWithdrawalRecursive3']


class UserIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    referredBy: Union[bool, 'UserArgsFromWithdrawalRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromWithdrawalRecursive4']
    balance: Union[bool, 'BalanceArgsFromWithdrawalRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromWithdrawalRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromWithdrawalRecursive4']


class UserIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class UserArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyUserArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive1']


class BalanceIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive2']


class BalanceIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive3']


class BalanceIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive4']


class BalanceIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class BalanceArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyBalanceArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive1']


class TransactionIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive2']


class TransactionIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive3']


class TransactionIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive4']


class TransactionIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class TransactionArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyTransactionArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive1']


class DepositIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive2']


class DepositIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive3']


class DepositIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive4']


class DepositIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class DepositArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyDepositArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive1']


class WithdrawalIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive2']


class WithdrawalIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive3']


class WithdrawalIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromWithdrawalRecursive4']


class WithdrawalIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class WithdrawalArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyWithdrawalArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive1']


class CryptoOrderIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive2']


class CryptoOrderIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive3']


class CryptoOrderIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    user: Union[bool, 'UserArgsFromWithdrawalRecursive4']


class CryptoOrderIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class CryptoOrderArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyCryptoOrderArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class SettingIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class SettingIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class SettingIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class SettingIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class SettingArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManySettingArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class CoinSettingIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class CoinSettingIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class CoinSettingIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class CoinSettingIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class CoinSettingArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyCoinSettingArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class PaymentMethodIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class PaymentMethodIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class PaymentMethodIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class PaymentMethodIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class PaymentMethodArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyPaymentMethodArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive1']


class AdminIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive2']


class AdminIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive3']


class AdminIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromWithdrawalRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromWithdrawalRecursive4']


class AdminIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class AdminArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyAdminArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromWithdrawal(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class ReferralSettingIncludeFromWithdrawalRecursive1(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class ReferralSettingIncludeFromWithdrawalRecursive2(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class ReferralSettingIncludeFromWithdrawalRecursive3(TypedDict, total=False):
    """Relational arguments for Withdrawal"""


class ReferralSettingIncludeFromWithdrawalRecursive4(TypedDict, total=False):
    """Relational arguments for Withdrawal"""

    

class ReferralSettingArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    
    

class FindManyReferralSettingArgsFromWithdrawal(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromWithdrawalRecursive1(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromWithdrawalRecursive2(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromWithdrawalRecursive3(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromWithdrawalRecursive4(TypedDict, total=False):
    """Arguments for Withdrawal"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyWithdrawalArgs = FindManyWithdrawalArgsFromWithdrawal
FindFirstWithdrawalArgs = FindManyWithdrawalArgsFromWithdrawal


    

class WithdrawalWhereInput(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    bankName: Union[None, _str, 'types.StringFilter']
    accountNumber: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    ewalletType: Union[None, _str, 'types.StringFilter']
    ewalletNumber: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WithdrawalWhereInputRecursive1', List['WithdrawalWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['WithdrawalWhereInputRecursive1']
    OR: List['WithdrawalWhereInputRecursive1']
    NOT: List['WithdrawalWhereInputRecursive1']


class WithdrawalWhereInputRecursive1(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    bankName: Union[None, _str, 'types.StringFilter']
    accountNumber: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    ewalletType: Union[None, _str, 'types.StringFilter']
    ewalletNumber: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WithdrawalWhereInputRecursive2', List['WithdrawalWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['WithdrawalWhereInputRecursive2']
    OR: List['WithdrawalWhereInputRecursive2']
    NOT: List['WithdrawalWhereInputRecursive2']


class WithdrawalWhereInputRecursive2(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    bankName: Union[None, _str, 'types.StringFilter']
    accountNumber: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    ewalletType: Union[None, _str, 'types.StringFilter']
    ewalletNumber: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WithdrawalWhereInputRecursive3', List['WithdrawalWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['WithdrawalWhereInputRecursive3']
    OR: List['WithdrawalWhereInputRecursive3']
    NOT: List['WithdrawalWhereInputRecursive3']


class WithdrawalWhereInputRecursive3(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    bankName: Union[None, _str, 'types.StringFilter']
    accountNumber: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    ewalletType: Union[None, _str, 'types.StringFilter']
    ewalletNumber: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['WithdrawalWhereInputRecursive4', List['WithdrawalWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['WithdrawalWhereInputRecursive4']
    OR: List['WithdrawalWhereInputRecursive4']
    NOT: List['WithdrawalWhereInputRecursive4']


class WithdrawalWhereInputRecursive4(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    amount: Union[decimal.Decimal, 'types.DecimalFilter']
    bankName: Union[None, _str, 'types.StringFilter']
    accountNumber: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    ewalletType: Union[None, _str, 'types.StringFilter']
    ewalletNumber: Union[None, _str, 'types.StringFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[None, _str, 'types.StringFilter']
    approvedById: Union[None, _str, 'types.StringFilter']
    approvedBy: 'AdminRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Withdrawal types


    

class WithdrawalScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    bankName: Union[_str, 'types.StringWithAggregatesFilter']
    accountNumber: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletType: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletNumber: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WithdrawalScalarWhereWithAggregatesInputRecursive1']
    OR: List['WithdrawalScalarWhereWithAggregatesInputRecursive1']
    NOT: List['WithdrawalScalarWhereWithAggregatesInputRecursive1']


class WithdrawalScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    bankName: Union[_str, 'types.StringWithAggregatesFilter']
    accountNumber: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletType: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletNumber: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WithdrawalScalarWhereWithAggregatesInputRecursive2']
    OR: List['WithdrawalScalarWhereWithAggregatesInputRecursive2']
    NOT: List['WithdrawalScalarWhereWithAggregatesInputRecursive2']


class WithdrawalScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    bankName: Union[_str, 'types.StringWithAggregatesFilter']
    accountNumber: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletType: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletNumber: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WithdrawalScalarWhereWithAggregatesInputRecursive3']
    OR: List['WithdrawalScalarWhereWithAggregatesInputRecursive3']
    NOT: List['WithdrawalScalarWhereWithAggregatesInputRecursive3']


class WithdrawalScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    bankName: Union[_str, 'types.StringWithAggregatesFilter']
    accountNumber: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletType: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletNumber: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['WithdrawalScalarWhereWithAggregatesInputRecursive4']
    OR: List['WithdrawalScalarWhereWithAggregatesInputRecursive4']
    NOT: List['WithdrawalScalarWhereWithAggregatesInputRecursive4']


class WithdrawalScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Withdrawal arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    amount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    bankName: Union[_str, 'types.StringWithAggregatesFilter']
    accountNumber: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletType: Union[_str, 'types.StringWithAggregatesFilter']
    ewalletNumber: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.TransactionStatus'
    adminNote: Union[_str, 'types.StringWithAggregatesFilter']
    approvedById: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class WithdrawalGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    amount: decimal.Decimal
    bankName: _str
    accountNumber: _str
    accountName: _str
    ewalletType: _str
    ewalletNumber: _str
    status: 'enums.TransactionStatus'
    adminNote: _str
    approvedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'WithdrawalSumAggregateOutput'
    _avg: 'WithdrawalAvgAggregateOutput'
    _min: 'WithdrawalMinAggregateOutput'
    _max: 'WithdrawalMaxAggregateOutput'
    _count: 'WithdrawalCountAggregateOutput'


class WithdrawalAvgAggregateOutput(TypedDict, total=False):
    """Withdrawal output for aggregating averages"""


class WithdrawalSumAggregateOutput(TypedDict, total=False):
    """Withdrawal output for aggregating sums"""


class WithdrawalScalarAggregateOutput(TypedDict, total=False):
    """Withdrawal output including scalar fields"""
    id: _str
    userId: _str
    amount: decimal.Decimal
    bankName: _str
    accountNumber: _str
    accountName: _str
    ewalletType: _str
    ewalletNumber: _str
    status: 'enums.TransactionStatus'
    adminNote: _str
    approvedById: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


WithdrawalMinAggregateOutput = WithdrawalScalarAggregateOutput
WithdrawalMaxAggregateOutput = WithdrawalScalarAggregateOutput


class WithdrawalMaxAggregateInput(TypedDict, total=False):
    """Withdrawal input for aggregating by max"""
    id: bool
    userId: bool
    amount: bool
    bankName: bool
    accountNumber: bool
    accountName: bool
    ewalletType: bool
    ewalletNumber: bool
    status: bool
    adminNote: bool
    approvedById: bool
    createdAt: bool
    updatedAt: bool


class WithdrawalMinAggregateInput(TypedDict, total=False):
    """Withdrawal input for aggregating by min"""
    id: bool
    userId: bool
    amount: bool
    bankName: bool
    accountNumber: bool
    accountName: bool
    ewalletType: bool
    ewalletNumber: bool
    status: bool
    adminNote: bool
    approvedById: bool
    createdAt: bool
    updatedAt: bool


class WithdrawalNumberAggregateInput(TypedDict, total=False):
    """Withdrawal input for aggregating numbers"""


WithdrawalAvgAggregateInput = WithdrawalNumberAggregateInput
WithdrawalSumAggregateInput = WithdrawalNumberAggregateInput


WithdrawalCountAggregateInput = TypedDict(
    'WithdrawalCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'amount': bool,
        'bankName': bool,
        'accountNumber': bool,
        'accountName': bool,
        'ewalletType': bool,
        'ewalletNumber': bool,
        'status': bool,
        'adminNote': bool,
        'approvedById': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

WithdrawalCountAggregateOutput = TypedDict(
    'WithdrawalCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'amount': int,
        'bankName': int,
        'accountNumber': int,
        'accountName': int,
        'ewalletType': int,
        'ewalletNumber': int,
        'status': int,
        'adminNote': int,
        'approvedById': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


WithdrawalKeys = Literal[
    'id',
    'userId',
    'user',
    'amount',
    'bankName',
    'accountNumber',
    'accountName',
    'ewalletType',
    'ewalletNumber',
    'status',
    'adminNote',
    'approvedById',
    'approvedBy',
    'createdAt',
    'updatedAt',
]
WithdrawalScalarFieldKeys = Literal[
    'id',
    'userId',
    'amount',
    'bankName',
    'accountNumber',
    'accountName',
    'ewalletType',
    'ewalletNumber',
    'status',
    'adminNote',
    'approvedById',
    'createdAt',
    'updatedAt',
]
WithdrawalScalarFieldKeysT = TypeVar('WithdrawalScalarFieldKeysT', bound=WithdrawalScalarFieldKeys)

WithdrawalRelationalFieldKeys = Literal[
        'user',
        'approvedBy',
    ]

# CryptoOrder types

class CryptoOrderOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CryptoOrder create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    walletAddress: Optional[_str]
    depositAddress: Optional[_str]
    oxapayPaymentId: Optional[_str]
    oxapayPayoutId: Optional[_str]
    txHash: Optional[_str]
    status: 'enums.OrderStatus'
    expiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CryptoOrderCreateInput(CryptoOrderOptionalCreateInput):
    """Required arguments to the CryptoOrder create method"""
    orderType: 'enums.OrderType'
    coinSymbol: _str
    network: _str
    cryptoAmount: decimal.Decimal
    fiatAmount: decimal.Decimal
    rate: decimal.Decimal
    margin: decimal.Decimal
    networkFee: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CryptoOrderOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CryptoOrder create method, without relations"""
    id: _str
    userId: _str
    walletAddress: Optional[_str]
    depositAddress: Optional[_str]
    oxapayPaymentId: Optional[_str]
    oxapayPayoutId: Optional[_str]
    txHash: Optional[_str]
    status: 'enums.OrderStatus'
    expiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CryptoOrderCreateWithoutRelationsInput(CryptoOrderOptionalCreateWithoutRelationsInput):
    """Required arguments to the CryptoOrder create method, without relations"""
    orderType: 'enums.OrderType'
    coinSymbol: _str
    network: _str
    cryptoAmount: decimal.Decimal
    fiatAmount: decimal.Decimal
    rate: decimal.Decimal
    margin: decimal.Decimal
    networkFee: decimal.Decimal

class CryptoOrderConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CryptoOrderCreateWithoutRelationsInput'
    where: 'CryptoOrderWhereUniqueInput'

class CryptoOrderCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CryptoOrderCreateWithoutRelationsInput'
    connect: 'CryptoOrderWhereUniqueInput'
    connect_or_create: 'CryptoOrderConnectOrCreateWithoutRelationsInput'


class CryptoOrderCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CryptoOrderCreateWithoutRelationsInput', List['CryptoOrderCreateWithoutRelationsInput']]
    connect: Union['CryptoOrderWhereUniqueInput', List['CryptoOrderWhereUniqueInput']]
    connect_or_create: Union['CryptoOrderConnectOrCreateWithoutRelationsInput', List['CryptoOrderConnectOrCreateWithoutRelationsInput']]

_CryptoOrderWhereUnique_id_Input = TypedDict(
    '_CryptoOrderWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

CryptoOrderWhereUniqueInput = _CryptoOrderWhereUnique_id_Input


class CryptoOrderUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    orderType: 'enums.OrderType'
    coinSymbol: _str
    network: _str
    cryptoAmount: decimal.Decimal
    fiatAmount: decimal.Decimal
    rate: decimal.Decimal
    margin: decimal.Decimal
    networkFee: decimal.Decimal
    walletAddress: Optional[_str]
    depositAddress: Optional[_str]
    oxapayPaymentId: Optional[_str]
    oxapayPayoutId: Optional[_str]
    txHash: Optional[_str]
    status: 'enums.OrderStatus'
    expiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CryptoOrderUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    orderType: 'enums.OrderType'
    coinSymbol: _str
    network: _str
    cryptoAmount: decimal.Decimal
    fiatAmount: decimal.Decimal
    rate: decimal.Decimal
    margin: decimal.Decimal
    networkFee: decimal.Decimal
    walletAddress: Optional[_str]
    depositAddress: Optional[_str]
    oxapayPaymentId: Optional[_str]
    oxapayPayoutId: Optional[_str]
    txHash: Optional[_str]
    status: 'enums.OrderStatus'
    expiresAt: Optional[datetime.datetime]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CryptoOrderUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CryptoOrderCreateWithoutRelationsInput']
    connect: List['CryptoOrderWhereUniqueInput']
    connect_or_create: List['CryptoOrderConnectOrCreateWithoutRelationsInput']
    set: List['CryptoOrderWhereUniqueInput']
    disconnect: List['CryptoOrderWhereUniqueInput']
    delete: List['CryptoOrderWhereUniqueInput']

    # TODO
    # update: List['CryptoOrderUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CryptoOrderUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CryptoOrderScalarWhereInput']
    # upsert: List['CryptoOrderUpserteWithWhereUniqueWithoutRelationsInput']


class CryptoOrderUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CryptoOrderCreateWithoutRelationsInput'
    connect: 'CryptoOrderWhereUniqueInput'
    connect_or_create: 'CryptoOrderConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CryptoOrderUpdateInput'
    # upsert: 'CryptoOrderUpsertWithoutRelationsInput'


class CryptoOrderUpsertInput(TypedDict):
    create: 'CryptoOrderCreateInput'
    update: 'CryptoOrderUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CryptoOrder_id_OrderByInput = TypedDict(
    '_CryptoOrder_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_CryptoOrder_userId_OrderByInput = TypedDict(
    '_CryptoOrder_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_CryptoOrder_orderType_OrderByInput = TypedDict(
    '_CryptoOrder_orderType_OrderByInput',
    {
        'orderType': 'SortOrder',
    },
    total=True
)

_CryptoOrder_coinSymbol_OrderByInput = TypedDict(
    '_CryptoOrder_coinSymbol_OrderByInput',
    {
        'coinSymbol': 'SortOrder',
    },
    total=True
)

_CryptoOrder_network_OrderByInput = TypedDict(
    '_CryptoOrder_network_OrderByInput',
    {
        'network': 'SortOrder',
    },
    total=True
)

_CryptoOrder_cryptoAmount_OrderByInput = TypedDict(
    '_CryptoOrder_cryptoAmount_OrderByInput',
    {
        'cryptoAmount': 'SortOrder',
    },
    total=True
)

_CryptoOrder_fiatAmount_OrderByInput = TypedDict(
    '_CryptoOrder_fiatAmount_OrderByInput',
    {
        'fiatAmount': 'SortOrder',
    },
    total=True
)

_CryptoOrder_rate_OrderByInput = TypedDict(
    '_CryptoOrder_rate_OrderByInput',
    {
        'rate': 'SortOrder',
    },
    total=True
)

_CryptoOrder_margin_OrderByInput = TypedDict(
    '_CryptoOrder_margin_OrderByInput',
    {
        'margin': 'SortOrder',
    },
    total=True
)

_CryptoOrder_networkFee_OrderByInput = TypedDict(
    '_CryptoOrder_networkFee_OrderByInput',
    {
        'networkFee': 'SortOrder',
    },
    total=True
)

_CryptoOrder_walletAddress_OrderByInput = TypedDict(
    '_CryptoOrder_walletAddress_OrderByInput',
    {
        'walletAddress': 'SortOrder',
    },
    total=True
)

_CryptoOrder_depositAddress_OrderByInput = TypedDict(
    '_CryptoOrder_depositAddress_OrderByInput',
    {
        'depositAddress': 'SortOrder',
    },
    total=True
)

_CryptoOrder_oxapayPaymentId_OrderByInput = TypedDict(
    '_CryptoOrder_oxapayPaymentId_OrderByInput',
    {
        'oxapayPaymentId': 'SortOrder',
    },
    total=True
)

_CryptoOrder_oxapayPayoutId_OrderByInput = TypedDict(
    '_CryptoOrder_oxapayPayoutId_OrderByInput',
    {
        'oxapayPayoutId': 'SortOrder',
    },
    total=True
)

_CryptoOrder_txHash_OrderByInput = TypedDict(
    '_CryptoOrder_txHash_OrderByInput',
    {
        'txHash': 'SortOrder',
    },
    total=True
)

_CryptoOrder_status_OrderByInput = TypedDict(
    '_CryptoOrder_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_CryptoOrder_expiresAt_OrderByInput = TypedDict(
    '_CryptoOrder_expiresAt_OrderByInput',
    {
        'expiresAt': 'SortOrder',
    },
    total=True
)

_CryptoOrder_createdAt_OrderByInput = TypedDict(
    '_CryptoOrder_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_CryptoOrder_updatedAt_OrderByInput = TypedDict(
    '_CryptoOrder_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_CryptoOrder_RelevanceInner = TypedDict(
    '_CryptoOrder_RelevanceInner',
    {
        'fields': 'List[CryptoOrderScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_CryptoOrder_RelevanceOrderByInput = TypedDict(
    '_CryptoOrder_RelevanceOrderByInput',
    {
        '_relevance': '_CryptoOrder_RelevanceInner',
    },
    total=True
)

CryptoOrderOrderByInput = Union[
    '_CryptoOrder_id_OrderByInput',
    '_CryptoOrder_userId_OrderByInput',
    '_CryptoOrder_orderType_OrderByInput',
    '_CryptoOrder_coinSymbol_OrderByInput',
    '_CryptoOrder_network_OrderByInput',
    '_CryptoOrder_cryptoAmount_OrderByInput',
    '_CryptoOrder_fiatAmount_OrderByInput',
    '_CryptoOrder_rate_OrderByInput',
    '_CryptoOrder_margin_OrderByInput',
    '_CryptoOrder_networkFee_OrderByInput',
    '_CryptoOrder_walletAddress_OrderByInput',
    '_CryptoOrder_depositAddress_OrderByInput',
    '_CryptoOrder_oxapayPaymentId_OrderByInput',
    '_CryptoOrder_oxapayPayoutId_OrderByInput',
    '_CryptoOrder_txHash_OrderByInput',
    '_CryptoOrder_status_OrderByInput',
    '_CryptoOrder_expiresAt_OrderByInput',
    '_CryptoOrder_createdAt_OrderByInput',
    '_CryptoOrder_updatedAt_OrderByInput',
    '_CryptoOrder_RelevanceOrderByInput',
]



# recursive CryptoOrder types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CryptoOrderRelationFilter = TypedDict(
    'CryptoOrderRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CryptoOrderListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CryptoOrderInclude(TypedDict, total=False):
    """CryptoOrder relational arguments"""
    user: Union[bool, 'UserArgsFromCryptoOrder']


    

class UserIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    referredBy: Union[bool, 'UserArgsFromCryptoOrderRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromCryptoOrderRecursive1']
    balance: Union[bool, 'BalanceArgsFromCryptoOrderRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromCryptoOrderRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCryptoOrderRecursive1']


class UserIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    referredBy: Union[bool, 'UserArgsFromCryptoOrderRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromCryptoOrderRecursive2']
    balance: Union[bool, 'BalanceArgsFromCryptoOrderRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromCryptoOrderRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCryptoOrderRecursive2']


class UserIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    referredBy: Union[bool, 'UserArgsFromCryptoOrderRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromCryptoOrderRecursive3']
    balance: Union[bool, 'BalanceArgsFromCryptoOrderRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromCryptoOrderRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCryptoOrderRecursive3']


class UserIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    referredBy: Union[bool, 'UserArgsFromCryptoOrderRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromCryptoOrderRecursive4']
    balance: Union[bool, 'BalanceArgsFromCryptoOrderRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromCryptoOrderRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCryptoOrderRecursive4']


class UserIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class UserArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyUserArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive1']


class BalanceIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive2']


class BalanceIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive3']


class BalanceIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive4']


class BalanceIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class BalanceArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyBalanceArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive1']


class TransactionIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive2']


class TransactionIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive3']


class TransactionIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive4']


class TransactionIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class TransactionArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyTransactionArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive1']


class DepositIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive2']


class DepositIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive3']


class DepositIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive4']


class DepositIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class DepositArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyDepositArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive1']


class WithdrawalIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive2']


class WithdrawalIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive3']


class WithdrawalIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromCryptoOrderRecursive4']


class WithdrawalIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class WithdrawalArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyWithdrawalArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive1']


class CryptoOrderIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive2']


class CryptoOrderIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive3']


class CryptoOrderIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    user: Union[bool, 'UserArgsFromCryptoOrderRecursive4']


class CryptoOrderIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class CryptoOrderArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyCryptoOrderArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class SettingIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class SettingIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class SettingIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class SettingIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class SettingArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManySettingArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class CoinSettingIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class CoinSettingIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class CoinSettingIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class CoinSettingIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class CoinSettingArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyCoinSettingArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class PaymentMethodIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class PaymentMethodIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class PaymentMethodIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class PaymentMethodIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class PaymentMethodArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyPaymentMethodArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive1']


class AdminIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive2']


class AdminIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive3']


class AdminIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCryptoOrderRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCryptoOrderRecursive4']


class AdminIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class AdminArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyAdminArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromCryptoOrder(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class ReferralSettingIncludeFromCryptoOrderRecursive1(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class ReferralSettingIncludeFromCryptoOrderRecursive2(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class ReferralSettingIncludeFromCryptoOrderRecursive3(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""


class ReferralSettingIncludeFromCryptoOrderRecursive4(TypedDict, total=False):
    """Relational arguments for CryptoOrder"""

    

class ReferralSettingArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    
    

class FindManyReferralSettingArgsFromCryptoOrder(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromCryptoOrderRecursive1(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromCryptoOrderRecursive2(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromCryptoOrderRecursive3(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromCryptoOrderRecursive4(TypedDict, total=False):
    """Arguments for CryptoOrder"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyCryptoOrderArgs = FindManyCryptoOrderArgsFromCryptoOrder
FindFirstCryptoOrderArgs = FindManyCryptoOrderArgsFromCryptoOrder


    

class CryptoOrderWhereInput(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    rate: Union[decimal.Decimal, 'types.DecimalFilter']
    margin: Union[decimal.Decimal, 'types.DecimalFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalFilter']
    walletAddress: Union[None, _str, 'types.StringFilter']
    depositAddress: Union[None, _str, 'types.StringFilter']
    oxapayPaymentId: Union[None, _str, 'types.StringFilter']
    oxapayPayoutId: Union[None, _str, 'types.StringFilter']
    txHash: Union[None, _str, 'types.StringFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CryptoOrderWhereInputRecursive1', List['CryptoOrderWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CryptoOrderWhereInputRecursive1']
    OR: List['CryptoOrderWhereInputRecursive1']
    NOT: List['CryptoOrderWhereInputRecursive1']


class CryptoOrderWhereInputRecursive1(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    rate: Union[decimal.Decimal, 'types.DecimalFilter']
    margin: Union[decimal.Decimal, 'types.DecimalFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalFilter']
    walletAddress: Union[None, _str, 'types.StringFilter']
    depositAddress: Union[None, _str, 'types.StringFilter']
    oxapayPaymentId: Union[None, _str, 'types.StringFilter']
    oxapayPayoutId: Union[None, _str, 'types.StringFilter']
    txHash: Union[None, _str, 'types.StringFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CryptoOrderWhereInputRecursive2', List['CryptoOrderWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CryptoOrderWhereInputRecursive2']
    OR: List['CryptoOrderWhereInputRecursive2']
    NOT: List['CryptoOrderWhereInputRecursive2']


class CryptoOrderWhereInputRecursive2(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    rate: Union[decimal.Decimal, 'types.DecimalFilter']
    margin: Union[decimal.Decimal, 'types.DecimalFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalFilter']
    walletAddress: Union[None, _str, 'types.StringFilter']
    depositAddress: Union[None, _str, 'types.StringFilter']
    oxapayPaymentId: Union[None, _str, 'types.StringFilter']
    oxapayPayoutId: Union[None, _str, 'types.StringFilter']
    txHash: Union[None, _str, 'types.StringFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CryptoOrderWhereInputRecursive3', List['CryptoOrderWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CryptoOrderWhereInputRecursive3']
    OR: List['CryptoOrderWhereInputRecursive3']
    NOT: List['CryptoOrderWhereInputRecursive3']


class CryptoOrderWhereInputRecursive3(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    rate: Union[decimal.Decimal, 'types.DecimalFilter']
    margin: Union[decimal.Decimal, 'types.DecimalFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalFilter']
    walletAddress: Union[None, _str, 'types.StringFilter']
    depositAddress: Union[None, _str, 'types.StringFilter']
    oxapayPaymentId: Union[None, _str, 'types.StringFilter']
    oxapayPayoutId: Union[None, _str, 'types.StringFilter']
    txHash: Union[None, _str, 'types.StringFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CryptoOrderWhereInputRecursive4', List['CryptoOrderWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CryptoOrderWhereInputRecursive4']
    OR: List['CryptoOrderWhereInputRecursive4']
    NOT: List['CryptoOrderWhereInputRecursive4']


class CryptoOrderWhereInputRecursive4(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalFilter']
    rate: Union[decimal.Decimal, 'types.DecimalFilter']
    margin: Union[decimal.Decimal, 'types.DecimalFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalFilter']
    walletAddress: Union[None, _str, 'types.StringFilter']
    depositAddress: Union[None, _str, 'types.StringFilter']
    oxapayPaymentId: Union[None, _str, 'types.StringFilter']
    oxapayPayoutId: Union[None, _str, 'types.StringFilter']
    txHash: Union[None, _str, 'types.StringFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[None, datetime.datetime, 'types.DateTimeFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate CryptoOrder types


    

class CryptoOrderScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    rate: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    margin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    walletAddress: Union[_str, 'types.StringWithAggregatesFilter']
    depositAddress: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPaymentId: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPayoutId: Union[_str, 'types.StringWithAggregatesFilter']
    txHash: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CryptoOrderScalarWhereWithAggregatesInputRecursive1']
    OR: List['CryptoOrderScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CryptoOrderScalarWhereWithAggregatesInputRecursive1']


class CryptoOrderScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    rate: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    margin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    walletAddress: Union[_str, 'types.StringWithAggregatesFilter']
    depositAddress: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPaymentId: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPayoutId: Union[_str, 'types.StringWithAggregatesFilter']
    txHash: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CryptoOrderScalarWhereWithAggregatesInputRecursive2']
    OR: List['CryptoOrderScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CryptoOrderScalarWhereWithAggregatesInputRecursive2']


class CryptoOrderScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    rate: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    margin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    walletAddress: Union[_str, 'types.StringWithAggregatesFilter']
    depositAddress: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPaymentId: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPayoutId: Union[_str, 'types.StringWithAggregatesFilter']
    txHash: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CryptoOrderScalarWhereWithAggregatesInputRecursive3']
    OR: List['CryptoOrderScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CryptoOrderScalarWhereWithAggregatesInputRecursive3']


class CryptoOrderScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    rate: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    margin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    walletAddress: Union[_str, 'types.StringWithAggregatesFilter']
    depositAddress: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPaymentId: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPayoutId: Union[_str, 'types.StringWithAggregatesFilter']
    txHash: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CryptoOrderScalarWhereWithAggregatesInputRecursive4']
    OR: List['CryptoOrderScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CryptoOrderScalarWhereWithAggregatesInputRecursive4']


class CryptoOrderScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """CryptoOrder arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    orderType: 'enums.OrderType'
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    cryptoAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    fiatAmount: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    rate: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    margin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    networkFee: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    walletAddress: Union[_str, 'types.StringWithAggregatesFilter']
    depositAddress: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPaymentId: Union[_str, 'types.StringWithAggregatesFilter']
    oxapayPayoutId: Union[_str, 'types.StringWithAggregatesFilter']
    txHash: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.OrderStatus'
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class CryptoOrderGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    orderType: 'enums.OrderType'
    coinSymbol: _str
    network: _str
    cryptoAmount: decimal.Decimal
    fiatAmount: decimal.Decimal
    rate: decimal.Decimal
    margin: decimal.Decimal
    networkFee: decimal.Decimal
    walletAddress: _str
    depositAddress: _str
    oxapayPaymentId: _str
    oxapayPayoutId: _str
    txHash: _str
    status: 'enums.OrderStatus'
    expiresAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CryptoOrderSumAggregateOutput'
    _avg: 'CryptoOrderAvgAggregateOutput'
    _min: 'CryptoOrderMinAggregateOutput'
    _max: 'CryptoOrderMaxAggregateOutput'
    _count: 'CryptoOrderCountAggregateOutput'


class CryptoOrderAvgAggregateOutput(TypedDict, total=False):
    """CryptoOrder output for aggregating averages"""


class CryptoOrderSumAggregateOutput(TypedDict, total=False):
    """CryptoOrder output for aggregating sums"""


class CryptoOrderScalarAggregateOutput(TypedDict, total=False):
    """CryptoOrder output including scalar fields"""
    id: _str
    userId: _str
    orderType: 'enums.OrderType'
    coinSymbol: _str
    network: _str
    cryptoAmount: decimal.Decimal
    fiatAmount: decimal.Decimal
    rate: decimal.Decimal
    margin: decimal.Decimal
    networkFee: decimal.Decimal
    walletAddress: _str
    depositAddress: _str
    oxapayPaymentId: _str
    oxapayPayoutId: _str
    txHash: _str
    status: 'enums.OrderStatus'
    expiresAt: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CryptoOrderMinAggregateOutput = CryptoOrderScalarAggregateOutput
CryptoOrderMaxAggregateOutput = CryptoOrderScalarAggregateOutput


class CryptoOrderMaxAggregateInput(TypedDict, total=False):
    """CryptoOrder input for aggregating by max"""
    id: bool
    userId: bool
    orderType: bool
    coinSymbol: bool
    network: bool
    cryptoAmount: bool
    fiatAmount: bool
    rate: bool
    margin: bool
    networkFee: bool
    walletAddress: bool
    depositAddress: bool
    oxapayPaymentId: bool
    oxapayPayoutId: bool
    txHash: bool
    status: bool
    expiresAt: bool
    createdAt: bool
    updatedAt: bool


class CryptoOrderMinAggregateInput(TypedDict, total=False):
    """CryptoOrder input for aggregating by min"""
    id: bool
    userId: bool
    orderType: bool
    coinSymbol: bool
    network: bool
    cryptoAmount: bool
    fiatAmount: bool
    rate: bool
    margin: bool
    networkFee: bool
    walletAddress: bool
    depositAddress: bool
    oxapayPaymentId: bool
    oxapayPayoutId: bool
    txHash: bool
    status: bool
    expiresAt: bool
    createdAt: bool
    updatedAt: bool


class CryptoOrderNumberAggregateInput(TypedDict, total=False):
    """CryptoOrder input for aggregating numbers"""


CryptoOrderAvgAggregateInput = CryptoOrderNumberAggregateInput
CryptoOrderSumAggregateInput = CryptoOrderNumberAggregateInput


CryptoOrderCountAggregateInput = TypedDict(
    'CryptoOrderCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'orderType': bool,
        'coinSymbol': bool,
        'network': bool,
        'cryptoAmount': bool,
        'fiatAmount': bool,
        'rate': bool,
        'margin': bool,
        'networkFee': bool,
        'walletAddress': bool,
        'depositAddress': bool,
        'oxapayPaymentId': bool,
        'oxapayPayoutId': bool,
        'txHash': bool,
        'status': bool,
        'expiresAt': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CryptoOrderCountAggregateOutput = TypedDict(
    'CryptoOrderCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'orderType': int,
        'coinSymbol': int,
        'network': int,
        'cryptoAmount': int,
        'fiatAmount': int,
        'rate': int,
        'margin': int,
        'networkFee': int,
        'walletAddress': int,
        'depositAddress': int,
        'oxapayPaymentId': int,
        'oxapayPayoutId': int,
        'txHash': int,
        'status': int,
        'expiresAt': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CryptoOrderKeys = Literal[
    'id',
    'userId',
    'user',
    'orderType',
    'coinSymbol',
    'network',
    'cryptoAmount',
    'fiatAmount',
    'rate',
    'margin',
    'networkFee',
    'walletAddress',
    'depositAddress',
    'oxapayPaymentId',
    'oxapayPayoutId',
    'txHash',
    'status',
    'expiresAt',
    'createdAt',
    'updatedAt',
]
CryptoOrderScalarFieldKeys = Literal[
    'id',
    'userId',
    'orderType',
    'coinSymbol',
    'network',
    'cryptoAmount',
    'fiatAmount',
    'rate',
    'margin',
    'networkFee',
    'walletAddress',
    'depositAddress',
    'oxapayPaymentId',
    'oxapayPayoutId',
    'txHash',
    'status',
    'expiresAt',
    'createdAt',
    'updatedAt',
]
CryptoOrderScalarFieldKeysT = TypeVar('CryptoOrderScalarFieldKeysT', bound=CryptoOrderScalarFieldKeys)

CryptoOrderRelationalFieldKeys = Literal[
        'user',
    ]

# Setting types

class SettingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Setting create method"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SettingCreateInput(SettingOptionalCreateInput):
    """Required arguments to the Setting create method"""
    key: _str
    value: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SettingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Setting create method, without relations"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SettingCreateWithoutRelationsInput(SettingOptionalCreateWithoutRelationsInput):
    """Required arguments to the Setting create method, without relations"""
    key: _str
    value: _str

class SettingConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'SettingCreateWithoutRelationsInput'
    where: 'SettingWhereUniqueInput'

class SettingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SettingCreateWithoutRelationsInput'
    connect: 'SettingWhereUniqueInput'
    connect_or_create: 'SettingConnectOrCreateWithoutRelationsInput'


class SettingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SettingCreateWithoutRelationsInput', List['SettingCreateWithoutRelationsInput']]
    connect: Union['SettingWhereUniqueInput', List['SettingWhereUniqueInput']]
    connect_or_create: Union['SettingConnectOrCreateWithoutRelationsInput', List['SettingConnectOrCreateWithoutRelationsInput']]

_SettingWhereUnique_id_Input = TypedDict(
    '_SettingWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_SettingWhereUnique_key_Input = TypedDict(
    '_SettingWhereUnique_key_Input',
    {
        'key': '_str',
    },
    total=True
)

SettingWhereUniqueInput = Union[
    '_SettingWhereUnique_id_Input',
    '_SettingWhereUnique_key_Input',
]


class SettingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SettingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class SettingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SettingCreateWithoutRelationsInput']
    connect: List['SettingWhereUniqueInput']
    connect_or_create: List['SettingConnectOrCreateWithoutRelationsInput']
    set: List['SettingWhereUniqueInput']
    disconnect: List['SettingWhereUniqueInput']
    delete: List['SettingWhereUniqueInput']

    # TODO
    # update: List['SettingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SettingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SettingScalarWhereInput']
    # upsert: List['SettingUpserteWithWhereUniqueWithoutRelationsInput']


class SettingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SettingCreateWithoutRelationsInput'
    connect: 'SettingWhereUniqueInput'
    connect_or_create: 'SettingConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SettingUpdateInput'
    # upsert: 'SettingUpsertWithoutRelationsInput'


class SettingUpsertInput(TypedDict):
    create: 'SettingCreateInput'
    update: 'SettingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Setting_id_OrderByInput = TypedDict(
    '_Setting_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Setting_key_OrderByInput = TypedDict(
    '_Setting_key_OrderByInput',
    {
        'key': 'SortOrder',
    },
    total=True
)

_Setting_value_OrderByInput = TypedDict(
    '_Setting_value_OrderByInput',
    {
        'value': 'SortOrder',
    },
    total=True
)

_Setting_createdAt_OrderByInput = TypedDict(
    '_Setting_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Setting_updatedAt_OrderByInput = TypedDict(
    '_Setting_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Setting_RelevanceInner = TypedDict(
    '_Setting_RelevanceInner',
    {
        'fields': 'List[SettingScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Setting_RelevanceOrderByInput = TypedDict(
    '_Setting_RelevanceOrderByInput',
    {
        '_relevance': '_Setting_RelevanceInner',
    },
    total=True
)

SettingOrderByInput = Union[
    '_Setting_id_OrderByInput',
    '_Setting_key_OrderByInput',
    '_Setting_value_OrderByInput',
    '_Setting_createdAt_OrderByInput',
    '_Setting_updatedAt_OrderByInput',
    '_Setting_RelevanceOrderByInput',
]



# recursive Setting types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SettingRelationFilter = TypedDict(
    'SettingRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SettingListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SettingInclude(TypedDict, total=False):
    """Setting relational arguments"""


    

class UserIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    referredBy: Union[bool, 'UserArgsFromSettingRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromSettingRecursive1']
    balance: Union[bool, 'BalanceArgsFromSettingRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromSettingRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromSettingRecursive1']


class UserIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    referredBy: Union[bool, 'UserArgsFromSettingRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromSettingRecursive2']
    balance: Union[bool, 'BalanceArgsFromSettingRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromSettingRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromSettingRecursive2']


class UserIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    referredBy: Union[bool, 'UserArgsFromSettingRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromSettingRecursive3']
    balance: Union[bool, 'BalanceArgsFromSettingRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromSettingRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromSettingRecursive3']


class UserIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    referredBy: Union[bool, 'UserArgsFromSettingRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromSettingRecursive4']
    balance: Union[bool, 'BalanceArgsFromSettingRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromSettingRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromSettingRecursive4']


class UserIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class UserArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyUserArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive1']


class BalanceIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive2']


class BalanceIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive3']


class BalanceIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive4']


class BalanceIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class BalanceArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyBalanceArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive1']


class TransactionIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive2']


class TransactionIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive3']


class TransactionIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive4']


class TransactionIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class TransactionArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyTransactionArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive1']


class DepositIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive2']


class DepositIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive3']


class DepositIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive4']


class DepositIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class DepositArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyDepositArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive1']


class WithdrawalIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive2']


class WithdrawalIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive3']


class WithdrawalIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromSettingRecursive4']


class WithdrawalIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class WithdrawalArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyWithdrawalArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive1']


class CryptoOrderIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive2']


class CryptoOrderIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive3']


class CryptoOrderIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    user: Union[bool, 'UserArgsFromSettingRecursive4']


class CryptoOrderIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class CryptoOrderArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyCryptoOrderArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""


class SettingIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""


class SettingIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""


class SettingIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""


class SettingIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class SettingArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManySettingArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""


class CoinSettingIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""


class CoinSettingIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""


class CoinSettingIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""


class CoinSettingIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class CoinSettingArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyCoinSettingArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""


class PaymentMethodIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""


class PaymentMethodIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""


class PaymentMethodIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""


class PaymentMethodIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class PaymentMethodArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyPaymentMethodArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive1']


class AdminIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive2']


class AdminIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive3']


class AdminIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromSettingRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromSettingRecursive4']


class AdminIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class AdminArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyAdminArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromSetting(TypedDict, total=False):
    """Relational arguments for Setting"""


class ReferralSettingIncludeFromSettingRecursive1(TypedDict, total=False):
    """Relational arguments for Setting"""


class ReferralSettingIncludeFromSettingRecursive2(TypedDict, total=False):
    """Relational arguments for Setting"""


class ReferralSettingIncludeFromSettingRecursive3(TypedDict, total=False):
    """Relational arguments for Setting"""


class ReferralSettingIncludeFromSettingRecursive4(TypedDict, total=False):
    """Relational arguments for Setting"""

    

class ReferralSettingArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    
    

class FindManyReferralSettingArgsFromSetting(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromSettingRecursive1(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromSettingRecursive2(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromSettingRecursive3(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromSettingRecursive4(TypedDict, total=False):
    """Arguments for Setting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManySettingArgs = FindManySettingArgsFromSetting
FindFirstSettingArgs = FindManySettingArgsFromSetting


    

class SettingWhereInput(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    key: Union[_str, 'types.StringFilter']
    value: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SettingWhereInputRecursive1', List['SettingWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SettingWhereInputRecursive1']
    OR: List['SettingWhereInputRecursive1']
    NOT: List['SettingWhereInputRecursive1']


class SettingWhereInputRecursive1(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    key: Union[_str, 'types.StringFilter']
    value: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SettingWhereInputRecursive2', List['SettingWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SettingWhereInputRecursive2']
    OR: List['SettingWhereInputRecursive2']
    NOT: List['SettingWhereInputRecursive2']


class SettingWhereInputRecursive2(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    key: Union[_str, 'types.StringFilter']
    value: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SettingWhereInputRecursive3', List['SettingWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SettingWhereInputRecursive3']
    OR: List['SettingWhereInputRecursive3']
    NOT: List['SettingWhereInputRecursive3']


class SettingWhereInputRecursive3(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    key: Union[_str, 'types.StringFilter']
    value: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['SettingWhereInputRecursive4', List['SettingWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SettingWhereInputRecursive4']
    OR: List['SettingWhereInputRecursive4']
    NOT: List['SettingWhereInputRecursive4']


class SettingWhereInputRecursive4(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    key: Union[_str, 'types.StringFilter']
    value: Union[_str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate Setting types


    

class SettingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    key: Union[_str, 'types.StringWithAggregatesFilter']
    value: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SettingScalarWhereWithAggregatesInputRecursive1']
    OR: List['SettingScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SettingScalarWhereWithAggregatesInputRecursive1']


class SettingScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    key: Union[_str, 'types.StringWithAggregatesFilter']
    value: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SettingScalarWhereWithAggregatesInputRecursive2']
    OR: List['SettingScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SettingScalarWhereWithAggregatesInputRecursive2']


class SettingScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    key: Union[_str, 'types.StringWithAggregatesFilter']
    value: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SettingScalarWhereWithAggregatesInputRecursive3']
    OR: List['SettingScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SettingScalarWhereWithAggregatesInputRecursive3']


class SettingScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    key: Union[_str, 'types.StringWithAggregatesFilter']
    value: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['SettingScalarWhereWithAggregatesInputRecursive4']
    OR: List['SettingScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SettingScalarWhereWithAggregatesInputRecursive4']


class SettingScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Setting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    key: Union[_str, 'types.StringWithAggregatesFilter']
    value: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class SettingGroupByOutput(TypedDict, total=False):
    id: _str
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'SettingSumAggregateOutput'
    _avg: 'SettingAvgAggregateOutput'
    _min: 'SettingMinAggregateOutput'
    _max: 'SettingMaxAggregateOutput'
    _count: 'SettingCountAggregateOutput'


class SettingAvgAggregateOutput(TypedDict, total=False):
    """Setting output for aggregating averages"""


class SettingSumAggregateOutput(TypedDict, total=False):
    """Setting output for aggregating sums"""


class SettingScalarAggregateOutput(TypedDict, total=False):
    """Setting output including scalar fields"""
    id: _str
    key: _str
    value: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


SettingMinAggregateOutput = SettingScalarAggregateOutput
SettingMaxAggregateOutput = SettingScalarAggregateOutput


class SettingMaxAggregateInput(TypedDict, total=False):
    """Setting input for aggregating by max"""
    id: bool
    key: bool
    value: bool
    createdAt: bool
    updatedAt: bool


class SettingMinAggregateInput(TypedDict, total=False):
    """Setting input for aggregating by min"""
    id: bool
    key: bool
    value: bool
    createdAt: bool
    updatedAt: bool


class SettingNumberAggregateInput(TypedDict, total=False):
    """Setting input for aggregating numbers"""


SettingAvgAggregateInput = SettingNumberAggregateInput
SettingSumAggregateInput = SettingNumberAggregateInput


SettingCountAggregateInput = TypedDict(
    'SettingCountAggregateInput',
    {
        'id': bool,
        'key': bool,
        'value': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

SettingCountAggregateOutput = TypedDict(
    'SettingCountAggregateOutput',
    {
        'id': int,
        'key': int,
        'value': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


SettingKeys = Literal[
    'id',
    'key',
    'value',
    'createdAt',
    'updatedAt',
]
SettingScalarFieldKeys = Literal[
    'id',
    'key',
    'value',
    'createdAt',
    'updatedAt',
]
SettingScalarFieldKeysT = TypeVar('SettingScalarFieldKeysT', bound=SettingScalarFieldKeys)

SettingRelationalFieldKeys = _NoneType

# CoinSetting types

class CoinSettingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the CoinSetting create method"""
    id: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CoinSettingCreateInput(CoinSettingOptionalCreateInput):
    """Required arguments to the CoinSetting create method"""
    coinSymbol: _str
    network: _str
    buyMargin: decimal.Decimal
    sellMargin: decimal.Decimal
    minBuy: decimal.Decimal
    maxBuy: decimal.Decimal
    minSell: decimal.Decimal
    maxSell: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CoinSettingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the CoinSetting create method, without relations"""
    id: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CoinSettingCreateWithoutRelationsInput(CoinSettingOptionalCreateWithoutRelationsInput):
    """Required arguments to the CoinSetting create method, without relations"""
    coinSymbol: _str
    network: _str
    buyMargin: decimal.Decimal
    sellMargin: decimal.Decimal
    minBuy: decimal.Decimal
    maxBuy: decimal.Decimal
    minSell: decimal.Decimal
    maxSell: decimal.Decimal

class CoinSettingConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CoinSettingCreateWithoutRelationsInput'
    where: 'CoinSettingWhereUniqueInput'

class CoinSettingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CoinSettingCreateWithoutRelationsInput'
    connect: 'CoinSettingWhereUniqueInput'
    connect_or_create: 'CoinSettingConnectOrCreateWithoutRelationsInput'


class CoinSettingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CoinSettingCreateWithoutRelationsInput', List['CoinSettingCreateWithoutRelationsInput']]
    connect: Union['CoinSettingWhereUniqueInput', List['CoinSettingWhereUniqueInput']]
    connect_or_create: Union['CoinSettingConnectOrCreateWithoutRelationsInput', List['CoinSettingConnectOrCreateWithoutRelationsInput']]

_CoinSettingWhereUnique_id_Input = TypedDict(
    '_CoinSettingWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_CoinSettingCompoundcoinSymbol_networkKeyInner = TypedDict(
    '_CoinSettingCompoundcoinSymbol_networkKeyInner',
    {
        'coinSymbol': '_str',
        'network': '_str',
    },
    total=True
)

_CoinSettingCompoundcoinSymbol_networkKey = TypedDict(
    '_CoinSettingCompoundcoinSymbol_networkKey',
    {
        'coinSymbol_network': '_CoinSettingCompoundcoinSymbol_networkKeyInner',
    },
    total=True
)

CoinSettingWhereUniqueInput = Union[
    '_CoinSettingWhereUnique_id_Input',
    '_CoinSettingCompoundcoinSymbol_networkKey',
]


class CoinSettingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    coinSymbol: _str
    network: _str
    buyMargin: decimal.Decimal
    sellMargin: decimal.Decimal
    isActive: _bool
    minBuy: decimal.Decimal
    maxBuy: decimal.Decimal
    minSell: decimal.Decimal
    maxSell: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CoinSettingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    coinSymbol: _str
    network: _str
    buyMargin: decimal.Decimal
    sellMargin: decimal.Decimal
    isActive: _bool
    minBuy: decimal.Decimal
    maxBuy: decimal.Decimal
    minSell: decimal.Decimal
    maxSell: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class CoinSettingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CoinSettingCreateWithoutRelationsInput']
    connect: List['CoinSettingWhereUniqueInput']
    connect_or_create: List['CoinSettingConnectOrCreateWithoutRelationsInput']
    set: List['CoinSettingWhereUniqueInput']
    disconnect: List['CoinSettingWhereUniqueInput']
    delete: List['CoinSettingWhereUniqueInput']

    # TODO
    # update: List['CoinSettingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CoinSettingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CoinSettingScalarWhereInput']
    # upsert: List['CoinSettingUpserteWithWhereUniqueWithoutRelationsInput']


class CoinSettingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CoinSettingCreateWithoutRelationsInput'
    connect: 'CoinSettingWhereUniqueInput'
    connect_or_create: 'CoinSettingConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CoinSettingUpdateInput'
    # upsert: 'CoinSettingUpsertWithoutRelationsInput'


class CoinSettingUpsertInput(TypedDict):
    create: 'CoinSettingCreateInput'
    update: 'CoinSettingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_CoinSetting_id_OrderByInput = TypedDict(
    '_CoinSetting_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_CoinSetting_coinSymbol_OrderByInput = TypedDict(
    '_CoinSetting_coinSymbol_OrderByInput',
    {
        'coinSymbol': 'SortOrder',
    },
    total=True
)

_CoinSetting_network_OrderByInput = TypedDict(
    '_CoinSetting_network_OrderByInput',
    {
        'network': 'SortOrder',
    },
    total=True
)

_CoinSetting_buyMargin_OrderByInput = TypedDict(
    '_CoinSetting_buyMargin_OrderByInput',
    {
        'buyMargin': 'SortOrder',
    },
    total=True
)

_CoinSetting_sellMargin_OrderByInput = TypedDict(
    '_CoinSetting_sellMargin_OrderByInput',
    {
        'sellMargin': 'SortOrder',
    },
    total=True
)

_CoinSetting_isActive_OrderByInput = TypedDict(
    '_CoinSetting_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_CoinSetting_minBuy_OrderByInput = TypedDict(
    '_CoinSetting_minBuy_OrderByInput',
    {
        'minBuy': 'SortOrder',
    },
    total=True
)

_CoinSetting_maxBuy_OrderByInput = TypedDict(
    '_CoinSetting_maxBuy_OrderByInput',
    {
        'maxBuy': 'SortOrder',
    },
    total=True
)

_CoinSetting_minSell_OrderByInput = TypedDict(
    '_CoinSetting_minSell_OrderByInput',
    {
        'minSell': 'SortOrder',
    },
    total=True
)

_CoinSetting_maxSell_OrderByInput = TypedDict(
    '_CoinSetting_maxSell_OrderByInput',
    {
        'maxSell': 'SortOrder',
    },
    total=True
)

_CoinSetting_createdAt_OrderByInput = TypedDict(
    '_CoinSetting_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_CoinSetting_updatedAt_OrderByInput = TypedDict(
    '_CoinSetting_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_CoinSetting_RelevanceInner = TypedDict(
    '_CoinSetting_RelevanceInner',
    {
        'fields': 'List[CoinSettingScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_CoinSetting_RelevanceOrderByInput = TypedDict(
    '_CoinSetting_RelevanceOrderByInput',
    {
        '_relevance': '_CoinSetting_RelevanceInner',
    },
    total=True
)

CoinSettingOrderByInput = Union[
    '_CoinSetting_id_OrderByInput',
    '_CoinSetting_coinSymbol_OrderByInput',
    '_CoinSetting_network_OrderByInput',
    '_CoinSetting_buyMargin_OrderByInput',
    '_CoinSetting_sellMargin_OrderByInput',
    '_CoinSetting_isActive_OrderByInput',
    '_CoinSetting_minBuy_OrderByInput',
    '_CoinSetting_maxBuy_OrderByInput',
    '_CoinSetting_minSell_OrderByInput',
    '_CoinSetting_maxSell_OrderByInput',
    '_CoinSetting_createdAt_OrderByInput',
    '_CoinSetting_updatedAt_OrderByInput',
    '_CoinSetting_RelevanceOrderByInput',
]



# recursive CoinSetting types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

CoinSettingRelationFilter = TypedDict(
    'CoinSettingRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class CoinSettingListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class CoinSettingInclude(TypedDict, total=False):
    """CoinSetting relational arguments"""


    

class UserIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    referredBy: Union[bool, 'UserArgsFromCoinSettingRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromCoinSettingRecursive1']
    balance: Union[bool, 'BalanceArgsFromCoinSettingRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromCoinSettingRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCoinSettingRecursive1']


class UserIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    referredBy: Union[bool, 'UserArgsFromCoinSettingRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromCoinSettingRecursive2']
    balance: Union[bool, 'BalanceArgsFromCoinSettingRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromCoinSettingRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCoinSettingRecursive2']


class UserIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    referredBy: Union[bool, 'UserArgsFromCoinSettingRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromCoinSettingRecursive3']
    balance: Union[bool, 'BalanceArgsFromCoinSettingRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromCoinSettingRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCoinSettingRecursive3']


class UserIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    referredBy: Union[bool, 'UserArgsFromCoinSettingRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromCoinSettingRecursive4']
    balance: Union[bool, 'BalanceArgsFromCoinSettingRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromCoinSettingRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromCoinSettingRecursive4']


class UserIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class UserArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyUserArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive1']


class BalanceIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive2']


class BalanceIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive3']


class BalanceIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive4']


class BalanceIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class BalanceArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyBalanceArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive1']


class TransactionIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive2']


class TransactionIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive3']


class TransactionIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive4']


class TransactionIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class TransactionArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyTransactionArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive1']


class DepositIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive2']


class DepositIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive3']


class DepositIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive4']


class DepositIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class DepositArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyDepositArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive1']


class WithdrawalIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive2']


class WithdrawalIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive3']


class WithdrawalIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromCoinSettingRecursive4']


class WithdrawalIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class WithdrawalArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyWithdrawalArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive1']


class CryptoOrderIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive2']


class CryptoOrderIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive3']


class CryptoOrderIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    user: Union[bool, 'UserArgsFromCoinSettingRecursive4']


class CryptoOrderIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class CryptoOrderArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyCryptoOrderArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class SettingIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class SettingIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class SettingIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class SettingIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class SettingArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManySettingArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class CoinSettingIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class CoinSettingIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class CoinSettingIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class CoinSettingIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class CoinSettingArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyCoinSettingArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class PaymentMethodIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class PaymentMethodIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class PaymentMethodIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class PaymentMethodIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class PaymentMethodArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyPaymentMethodArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive1']


class AdminIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive2']


class AdminIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive3']


class AdminIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromCoinSettingRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromCoinSettingRecursive4']


class AdminIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class AdminArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyAdminArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromCoinSetting(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class ReferralSettingIncludeFromCoinSettingRecursive1(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class ReferralSettingIncludeFromCoinSettingRecursive2(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class ReferralSettingIncludeFromCoinSettingRecursive3(TypedDict, total=False):
    """Relational arguments for CoinSetting"""


class ReferralSettingIncludeFromCoinSettingRecursive4(TypedDict, total=False):
    """Relational arguments for CoinSetting"""

    

class ReferralSettingArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    
    

class FindManyReferralSettingArgsFromCoinSetting(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromCoinSettingRecursive1(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromCoinSettingRecursive2(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromCoinSettingRecursive3(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromCoinSettingRecursive4(TypedDict, total=False):
    """Arguments for CoinSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyCoinSettingArgs = FindManyCoinSettingArgsFromCoinSetting
FindFirstCoinSettingArgs = FindManyCoinSettingArgsFromCoinSetting


    

class CoinSettingWhereInput(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CoinSettingWhereInputRecursive1', List['CoinSettingWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['CoinSettingWhereInputRecursive1']
    OR: List['CoinSettingWhereInputRecursive1']
    NOT: List['CoinSettingWhereInputRecursive1']


class CoinSettingWhereInputRecursive1(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CoinSettingWhereInputRecursive2', List['CoinSettingWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['CoinSettingWhereInputRecursive2']
    OR: List['CoinSettingWhereInputRecursive2']
    NOT: List['CoinSettingWhereInputRecursive2']


class CoinSettingWhereInputRecursive2(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CoinSettingWhereInputRecursive3', List['CoinSettingWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['CoinSettingWhereInputRecursive3']
    OR: List['CoinSettingWhereInputRecursive3']
    NOT: List['CoinSettingWhereInputRecursive3']


class CoinSettingWhereInputRecursive3(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CoinSettingWhereInputRecursive4', List['CoinSettingWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['CoinSettingWhereInputRecursive4']
    OR: List['CoinSettingWhereInputRecursive4']
    NOT: List['CoinSettingWhereInputRecursive4']


class CoinSettingWhereInputRecursive4(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    coinSymbol: Union[_str, 'types.StringFilter']
    network: Union[_str, 'types.StringFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate CoinSetting types


    

class CoinSettingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CoinSettingScalarWhereWithAggregatesInputRecursive1']
    OR: List['CoinSettingScalarWhereWithAggregatesInputRecursive1']
    NOT: List['CoinSettingScalarWhereWithAggregatesInputRecursive1']


class CoinSettingScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CoinSettingScalarWhereWithAggregatesInputRecursive2']
    OR: List['CoinSettingScalarWhereWithAggregatesInputRecursive2']
    NOT: List['CoinSettingScalarWhereWithAggregatesInputRecursive2']


class CoinSettingScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CoinSettingScalarWhereWithAggregatesInputRecursive3']
    OR: List['CoinSettingScalarWhereWithAggregatesInputRecursive3']
    NOT: List['CoinSettingScalarWhereWithAggregatesInputRecursive3']


class CoinSettingScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CoinSettingScalarWhereWithAggregatesInputRecursive4']
    OR: List['CoinSettingScalarWhereWithAggregatesInputRecursive4']
    NOT: List['CoinSettingScalarWhereWithAggregatesInputRecursive4']


class CoinSettingScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """CoinSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    coinSymbol: Union[_str, 'types.StringWithAggregatesFilter']
    network: Union[_str, 'types.StringWithAggregatesFilter']
    buyMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    sellMargin: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    minBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxBuy: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    minSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    maxSell: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class CoinSettingGroupByOutput(TypedDict, total=False):
    id: _str
    coinSymbol: _str
    network: _str
    buyMargin: decimal.Decimal
    sellMargin: decimal.Decimal
    isActive: _bool
    minBuy: decimal.Decimal
    maxBuy: decimal.Decimal
    minSell: decimal.Decimal
    maxSell: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'CoinSettingSumAggregateOutput'
    _avg: 'CoinSettingAvgAggregateOutput'
    _min: 'CoinSettingMinAggregateOutput'
    _max: 'CoinSettingMaxAggregateOutput'
    _count: 'CoinSettingCountAggregateOutput'


class CoinSettingAvgAggregateOutput(TypedDict, total=False):
    """CoinSetting output for aggregating averages"""


class CoinSettingSumAggregateOutput(TypedDict, total=False):
    """CoinSetting output for aggregating sums"""


class CoinSettingScalarAggregateOutput(TypedDict, total=False):
    """CoinSetting output including scalar fields"""
    id: _str
    coinSymbol: _str
    network: _str
    buyMargin: decimal.Decimal
    sellMargin: decimal.Decimal
    isActive: _bool
    minBuy: decimal.Decimal
    maxBuy: decimal.Decimal
    minSell: decimal.Decimal
    maxSell: decimal.Decimal
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


CoinSettingMinAggregateOutput = CoinSettingScalarAggregateOutput
CoinSettingMaxAggregateOutput = CoinSettingScalarAggregateOutput


class CoinSettingMaxAggregateInput(TypedDict, total=False):
    """CoinSetting input for aggregating by max"""
    id: bool
    coinSymbol: bool
    network: bool
    buyMargin: bool
    sellMargin: bool
    isActive: bool
    minBuy: bool
    maxBuy: bool
    minSell: bool
    maxSell: bool
    createdAt: bool
    updatedAt: bool


class CoinSettingMinAggregateInput(TypedDict, total=False):
    """CoinSetting input for aggregating by min"""
    id: bool
    coinSymbol: bool
    network: bool
    buyMargin: bool
    sellMargin: bool
    isActive: bool
    minBuy: bool
    maxBuy: bool
    minSell: bool
    maxSell: bool
    createdAt: bool
    updatedAt: bool


class CoinSettingNumberAggregateInput(TypedDict, total=False):
    """CoinSetting input for aggregating numbers"""


CoinSettingAvgAggregateInput = CoinSettingNumberAggregateInput
CoinSettingSumAggregateInput = CoinSettingNumberAggregateInput


CoinSettingCountAggregateInput = TypedDict(
    'CoinSettingCountAggregateInput',
    {
        'id': bool,
        'coinSymbol': bool,
        'network': bool,
        'buyMargin': bool,
        'sellMargin': bool,
        'isActive': bool,
        'minBuy': bool,
        'maxBuy': bool,
        'minSell': bool,
        'maxSell': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

CoinSettingCountAggregateOutput = TypedDict(
    'CoinSettingCountAggregateOutput',
    {
        'id': int,
        'coinSymbol': int,
        'network': int,
        'buyMargin': int,
        'sellMargin': int,
        'isActive': int,
        'minBuy': int,
        'maxBuy': int,
        'minSell': int,
        'maxSell': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


CoinSettingKeys = Literal[
    'id',
    'coinSymbol',
    'network',
    'buyMargin',
    'sellMargin',
    'isActive',
    'minBuy',
    'maxBuy',
    'minSell',
    'maxSell',
    'createdAt',
    'updatedAt',
]
CoinSettingScalarFieldKeys = Literal[
    'id',
    'coinSymbol',
    'network',
    'buyMargin',
    'sellMargin',
    'isActive',
    'minBuy',
    'maxBuy',
    'minSell',
    'maxSell',
    'createdAt',
    'updatedAt',
]
CoinSettingScalarFieldKeysT = TypeVar('CoinSettingScalarFieldKeysT', bound=CoinSettingScalarFieldKeys)

CoinSettingRelationalFieldKeys = _NoneType

# PaymentMethod types

class PaymentMethodOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the PaymentMethod create method"""
    id: _str
    accountNo: Optional[_str]
    accountName: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentMethodCreateInput(PaymentMethodOptionalCreateInput):
    """Required arguments to the PaymentMethod create method"""
    type: _str
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class PaymentMethodOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the PaymentMethod create method, without relations"""
    id: _str
    accountNo: Optional[_str]
    accountName: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentMethodCreateWithoutRelationsInput(PaymentMethodOptionalCreateWithoutRelationsInput):
    """Required arguments to the PaymentMethod create method, without relations"""
    type: _str
    name: _str

class PaymentMethodConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'PaymentMethodCreateWithoutRelationsInput'
    where: 'PaymentMethodWhereUniqueInput'

class PaymentMethodCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentMethodCreateWithoutRelationsInput'
    connect: 'PaymentMethodWhereUniqueInput'
    connect_or_create: 'PaymentMethodConnectOrCreateWithoutRelationsInput'


class PaymentMethodCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['PaymentMethodCreateWithoutRelationsInput', List['PaymentMethodCreateWithoutRelationsInput']]
    connect: Union['PaymentMethodWhereUniqueInput', List['PaymentMethodWhereUniqueInput']]
    connect_or_create: Union['PaymentMethodConnectOrCreateWithoutRelationsInput', List['PaymentMethodConnectOrCreateWithoutRelationsInput']]

_PaymentMethodWhereUnique_id_Input = TypedDict(
    '_PaymentMethodWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

PaymentMethodWhereUniqueInput = _PaymentMethodWhereUnique_id_Input


class PaymentMethodUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    type: _str
    name: _str
    accountNo: Optional[_str]
    accountName: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentMethodUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: _str
    name: _str
    accountNo: Optional[_str]
    accountName: Optional[_str]
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class PaymentMethodUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['PaymentMethodCreateWithoutRelationsInput']
    connect: List['PaymentMethodWhereUniqueInput']
    connect_or_create: List['PaymentMethodConnectOrCreateWithoutRelationsInput']
    set: List['PaymentMethodWhereUniqueInput']
    disconnect: List['PaymentMethodWhereUniqueInput']
    delete: List['PaymentMethodWhereUniqueInput']

    # TODO
    # update: List['PaymentMethodUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['PaymentMethodUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['PaymentMethodScalarWhereInput']
    # upsert: List['PaymentMethodUpserteWithWhereUniqueWithoutRelationsInput']


class PaymentMethodUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'PaymentMethodCreateWithoutRelationsInput'
    connect: 'PaymentMethodWhereUniqueInput'
    connect_or_create: 'PaymentMethodConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'PaymentMethodUpdateInput'
    # upsert: 'PaymentMethodUpsertWithoutRelationsInput'


class PaymentMethodUpsertInput(TypedDict):
    create: 'PaymentMethodCreateInput'
    update: 'PaymentMethodUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_PaymentMethod_id_OrderByInput = TypedDict(
    '_PaymentMethod_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_PaymentMethod_type_OrderByInput = TypedDict(
    '_PaymentMethod_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_PaymentMethod_name_OrderByInput = TypedDict(
    '_PaymentMethod_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_PaymentMethod_accountNo_OrderByInput = TypedDict(
    '_PaymentMethod_accountNo_OrderByInput',
    {
        'accountNo': 'SortOrder',
    },
    total=True
)

_PaymentMethod_accountName_OrderByInput = TypedDict(
    '_PaymentMethod_accountName_OrderByInput',
    {
        'accountName': 'SortOrder',
    },
    total=True
)

_PaymentMethod_isActive_OrderByInput = TypedDict(
    '_PaymentMethod_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_PaymentMethod_createdAt_OrderByInput = TypedDict(
    '_PaymentMethod_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_PaymentMethod_updatedAt_OrderByInput = TypedDict(
    '_PaymentMethod_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_PaymentMethod_RelevanceInner = TypedDict(
    '_PaymentMethod_RelevanceInner',
    {
        'fields': 'List[PaymentMethodScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_PaymentMethod_RelevanceOrderByInput = TypedDict(
    '_PaymentMethod_RelevanceOrderByInput',
    {
        '_relevance': '_PaymentMethod_RelevanceInner',
    },
    total=True
)

PaymentMethodOrderByInput = Union[
    '_PaymentMethod_id_OrderByInput',
    '_PaymentMethod_type_OrderByInput',
    '_PaymentMethod_name_OrderByInput',
    '_PaymentMethod_accountNo_OrderByInput',
    '_PaymentMethod_accountName_OrderByInput',
    '_PaymentMethod_isActive_OrderByInput',
    '_PaymentMethod_createdAt_OrderByInput',
    '_PaymentMethod_updatedAt_OrderByInput',
    '_PaymentMethod_RelevanceOrderByInput',
]



# recursive PaymentMethod types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

PaymentMethodRelationFilter = TypedDict(
    'PaymentMethodRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class PaymentMethodListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class PaymentMethodInclude(TypedDict, total=False):
    """PaymentMethod relational arguments"""


    

class UserIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    referredBy: Union[bool, 'UserArgsFromPaymentMethodRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromPaymentMethodRecursive1']
    balance: Union[bool, 'BalanceArgsFromPaymentMethodRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromPaymentMethodRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromPaymentMethodRecursive1']


class UserIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    referredBy: Union[bool, 'UserArgsFromPaymentMethodRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromPaymentMethodRecursive2']
    balance: Union[bool, 'BalanceArgsFromPaymentMethodRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromPaymentMethodRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromPaymentMethodRecursive2']


class UserIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    referredBy: Union[bool, 'UserArgsFromPaymentMethodRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromPaymentMethodRecursive3']
    balance: Union[bool, 'BalanceArgsFromPaymentMethodRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromPaymentMethodRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromPaymentMethodRecursive3']


class UserIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    referredBy: Union[bool, 'UserArgsFromPaymentMethodRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromPaymentMethodRecursive4']
    balance: Union[bool, 'BalanceArgsFromPaymentMethodRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromPaymentMethodRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromPaymentMethodRecursive4']


class UserIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class UserArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyUserArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive1']


class BalanceIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive2']


class BalanceIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive3']


class BalanceIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive4']


class BalanceIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class BalanceArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyBalanceArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive1']


class TransactionIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive2']


class TransactionIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive3']


class TransactionIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive4']


class TransactionIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class TransactionArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyTransactionArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive1']


class DepositIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive2']


class DepositIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive3']


class DepositIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive4']


class DepositIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class DepositArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyDepositArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive1']


class WithdrawalIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive2']


class WithdrawalIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive3']


class WithdrawalIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromPaymentMethodRecursive4']


class WithdrawalIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class WithdrawalArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyWithdrawalArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive1']


class CryptoOrderIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive2']


class CryptoOrderIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive3']


class CryptoOrderIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    user: Union[bool, 'UserArgsFromPaymentMethodRecursive4']


class CryptoOrderIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class CryptoOrderArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyCryptoOrderArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class SettingIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class SettingIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class SettingIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class SettingIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class SettingArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManySettingArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class CoinSettingIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class CoinSettingIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class CoinSettingIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class CoinSettingIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class CoinSettingArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyCoinSettingArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class PaymentMethodIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class PaymentMethodIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class PaymentMethodIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class PaymentMethodIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class PaymentMethodArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyPaymentMethodArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive1']


class AdminIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive2']


class AdminIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive3']


class AdminIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromPaymentMethodRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromPaymentMethodRecursive4']


class AdminIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class AdminArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyAdminArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromPaymentMethod(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class ReferralSettingIncludeFromPaymentMethodRecursive1(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class ReferralSettingIncludeFromPaymentMethodRecursive2(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class ReferralSettingIncludeFromPaymentMethodRecursive3(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""


class ReferralSettingIncludeFromPaymentMethodRecursive4(TypedDict, total=False):
    """Relational arguments for PaymentMethod"""

    

class ReferralSettingArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    
    

class FindManyReferralSettingArgsFromPaymentMethod(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromPaymentMethodRecursive1(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromPaymentMethodRecursive2(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromPaymentMethodRecursive3(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromPaymentMethodRecursive4(TypedDict, total=False):
    """Arguments for PaymentMethod"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyPaymentMethodArgs = FindManyPaymentMethodArgsFromPaymentMethod
FindFirstPaymentMethodArgs = FindManyPaymentMethodArgsFromPaymentMethod


    

class PaymentMethodWhereInput(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    accountNo: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PaymentMethodWhereInputRecursive1', List['PaymentMethodWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['PaymentMethodWhereInputRecursive1']
    OR: List['PaymentMethodWhereInputRecursive1']
    NOT: List['PaymentMethodWhereInputRecursive1']


class PaymentMethodWhereInputRecursive1(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    accountNo: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PaymentMethodWhereInputRecursive2', List['PaymentMethodWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['PaymentMethodWhereInputRecursive2']
    OR: List['PaymentMethodWhereInputRecursive2']
    NOT: List['PaymentMethodWhereInputRecursive2']


class PaymentMethodWhereInputRecursive2(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    accountNo: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PaymentMethodWhereInputRecursive3', List['PaymentMethodWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['PaymentMethodWhereInputRecursive3']
    OR: List['PaymentMethodWhereInputRecursive3']
    NOT: List['PaymentMethodWhereInputRecursive3']


class PaymentMethodWhereInputRecursive3(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    accountNo: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['PaymentMethodWhereInputRecursive4', List['PaymentMethodWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['PaymentMethodWhereInputRecursive4']
    OR: List['PaymentMethodWhereInputRecursive4']
    NOT: List['PaymentMethodWhereInputRecursive4']


class PaymentMethodWhereInputRecursive4(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    accountNo: Union[None, _str, 'types.StringFilter']
    accountName: Union[None, _str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate PaymentMethod types


    

class PaymentMethodScalarWhereWithAggregatesInput(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    accountNo: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PaymentMethodScalarWhereWithAggregatesInputRecursive1']
    OR: List['PaymentMethodScalarWhereWithAggregatesInputRecursive1']
    NOT: List['PaymentMethodScalarWhereWithAggregatesInputRecursive1']


class PaymentMethodScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    accountNo: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PaymentMethodScalarWhereWithAggregatesInputRecursive2']
    OR: List['PaymentMethodScalarWhereWithAggregatesInputRecursive2']
    NOT: List['PaymentMethodScalarWhereWithAggregatesInputRecursive2']


class PaymentMethodScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    accountNo: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PaymentMethodScalarWhereWithAggregatesInputRecursive3']
    OR: List['PaymentMethodScalarWhereWithAggregatesInputRecursive3']
    NOT: List['PaymentMethodScalarWhereWithAggregatesInputRecursive3']


class PaymentMethodScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    accountNo: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['PaymentMethodScalarWhereWithAggregatesInputRecursive4']
    OR: List['PaymentMethodScalarWhereWithAggregatesInputRecursive4']
    NOT: List['PaymentMethodScalarWhereWithAggregatesInputRecursive4']


class PaymentMethodScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """PaymentMethod arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    accountNo: Union[_str, 'types.StringWithAggregatesFilter']
    accountName: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class PaymentMethodGroupByOutput(TypedDict, total=False):
    id: _str
    type: _str
    name: _str
    accountNo: _str
    accountName: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'PaymentMethodSumAggregateOutput'
    _avg: 'PaymentMethodAvgAggregateOutput'
    _min: 'PaymentMethodMinAggregateOutput'
    _max: 'PaymentMethodMaxAggregateOutput'
    _count: 'PaymentMethodCountAggregateOutput'


class PaymentMethodAvgAggregateOutput(TypedDict, total=False):
    """PaymentMethod output for aggregating averages"""


class PaymentMethodSumAggregateOutput(TypedDict, total=False):
    """PaymentMethod output for aggregating sums"""


class PaymentMethodScalarAggregateOutput(TypedDict, total=False):
    """PaymentMethod output including scalar fields"""
    id: _str
    type: _str
    name: _str
    accountNo: _str
    accountName: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


PaymentMethodMinAggregateOutput = PaymentMethodScalarAggregateOutput
PaymentMethodMaxAggregateOutput = PaymentMethodScalarAggregateOutput


class PaymentMethodMaxAggregateInput(TypedDict, total=False):
    """PaymentMethod input for aggregating by max"""
    id: bool
    type: bool
    name: bool
    accountNo: bool
    accountName: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class PaymentMethodMinAggregateInput(TypedDict, total=False):
    """PaymentMethod input for aggregating by min"""
    id: bool
    type: bool
    name: bool
    accountNo: bool
    accountName: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class PaymentMethodNumberAggregateInput(TypedDict, total=False):
    """PaymentMethod input for aggregating numbers"""


PaymentMethodAvgAggregateInput = PaymentMethodNumberAggregateInput
PaymentMethodSumAggregateInput = PaymentMethodNumberAggregateInput


PaymentMethodCountAggregateInput = TypedDict(
    'PaymentMethodCountAggregateInput',
    {
        'id': bool,
        'type': bool,
        'name': bool,
        'accountNo': bool,
        'accountName': bool,
        'isActive': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

PaymentMethodCountAggregateOutput = TypedDict(
    'PaymentMethodCountAggregateOutput',
    {
        'id': int,
        'type': int,
        'name': int,
        'accountNo': int,
        'accountName': int,
        'isActive': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


PaymentMethodKeys = Literal[
    'id',
    'type',
    'name',
    'accountNo',
    'accountName',
    'isActive',
    'createdAt',
    'updatedAt',
]
PaymentMethodScalarFieldKeys = Literal[
    'id',
    'type',
    'name',
    'accountNo',
    'accountName',
    'isActive',
    'createdAt',
    'updatedAt',
]
PaymentMethodScalarFieldKeysT = TypeVar('PaymentMethodScalarFieldKeysT', bound=PaymentMethodScalarFieldKeys)

PaymentMethodRelationalFieldKeys = _NoneType

# Admin types

class AdminOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Admin create method"""
    id: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    approvedDeposits: 'DepositCreateManyNestedWithoutRelationsInput'
    approvedWithdrawals: 'WithdrawalCreateManyNestedWithoutRelationsInput'


class AdminCreateInput(AdminOptionalCreateInput):
    """Required arguments to the Admin create method"""
    username: _str
    passwordHash: _str
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AdminOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Admin create method, without relations"""
    id: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AdminCreateWithoutRelationsInput(AdminOptionalCreateWithoutRelationsInput):
    """Required arguments to the Admin create method, without relations"""
    username: _str
    passwordHash: _str
    name: _str

class AdminConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AdminCreateWithoutRelationsInput'
    where: 'AdminWhereUniqueInput'

class AdminCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AdminCreateWithoutRelationsInput'
    connect: 'AdminWhereUniqueInput'
    connect_or_create: 'AdminConnectOrCreateWithoutRelationsInput'


class AdminCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AdminCreateWithoutRelationsInput', List['AdminCreateWithoutRelationsInput']]
    connect: Union['AdminWhereUniqueInput', List['AdminWhereUniqueInput']]
    connect_or_create: Union['AdminConnectOrCreateWithoutRelationsInput', List['AdminConnectOrCreateWithoutRelationsInput']]

_AdminWhereUnique_id_Input = TypedDict(
    '_AdminWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_AdminWhereUnique_username_Input = TypedDict(
    '_AdminWhereUnique_username_Input',
    {
        'username': '_str',
    },
    total=True
)

AdminWhereUniqueInput = Union[
    '_AdminWhereUnique_id_Input',
    '_AdminWhereUnique_username_Input',
]


class AdminUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    username: _str
    passwordHash: _str
    name: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    approvedDeposits: 'DepositUpdateManyWithoutRelationsInput'
    approvedWithdrawals: 'WithdrawalUpdateManyWithoutRelationsInput'


class AdminUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    username: _str
    passwordHash: _str
    name: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class AdminUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AdminCreateWithoutRelationsInput']
    connect: List['AdminWhereUniqueInput']
    connect_or_create: List['AdminConnectOrCreateWithoutRelationsInput']
    set: List['AdminWhereUniqueInput']
    disconnect: List['AdminWhereUniqueInput']
    delete: List['AdminWhereUniqueInput']

    # TODO
    # update: List['AdminUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AdminUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AdminScalarWhereInput']
    # upsert: List['AdminUpserteWithWhereUniqueWithoutRelationsInput']


class AdminUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AdminCreateWithoutRelationsInput'
    connect: 'AdminWhereUniqueInput'
    connect_or_create: 'AdminConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AdminUpdateInput'
    # upsert: 'AdminUpsertWithoutRelationsInput'


class AdminUpsertInput(TypedDict):
    create: 'AdminCreateInput'
    update: 'AdminUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Admin_id_OrderByInput = TypedDict(
    '_Admin_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Admin_username_OrderByInput = TypedDict(
    '_Admin_username_OrderByInput',
    {
        'username': 'SortOrder',
    },
    total=True
)

_Admin_passwordHash_OrderByInput = TypedDict(
    '_Admin_passwordHash_OrderByInput',
    {
        'passwordHash': 'SortOrder',
    },
    total=True
)

_Admin_name_OrderByInput = TypedDict(
    '_Admin_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Admin_isActive_OrderByInput = TypedDict(
    '_Admin_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_Admin_createdAt_OrderByInput = TypedDict(
    '_Admin_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Admin_updatedAt_OrderByInput = TypedDict(
    '_Admin_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Admin_RelevanceInner = TypedDict(
    '_Admin_RelevanceInner',
    {
        'fields': 'List[AdminScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Admin_RelevanceOrderByInput = TypedDict(
    '_Admin_RelevanceOrderByInput',
    {
        '_relevance': '_Admin_RelevanceInner',
    },
    total=True
)

AdminOrderByInput = Union[
    '_Admin_id_OrderByInput',
    '_Admin_username_OrderByInput',
    '_Admin_passwordHash_OrderByInput',
    '_Admin_name_OrderByInput',
    '_Admin_isActive_OrderByInput',
    '_Admin_createdAt_OrderByInput',
    '_Admin_updatedAt_OrderByInput',
    '_Admin_RelevanceOrderByInput',
]



# recursive Admin types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

AdminRelationFilter = TypedDict(
    'AdminRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class AdminListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class AdminInclude(TypedDict, total=False):
    """Admin relational arguments"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromAdmin']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdmin']


    

class UserIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    referredBy: Union[bool, 'UserArgsFromAdminRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromAdminRecursive1']
    balance: Union[bool, 'BalanceArgsFromAdminRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromAdminRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromAdminRecursive1']


class UserIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    referredBy: Union[bool, 'UserArgsFromAdminRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromAdminRecursive2']
    balance: Union[bool, 'BalanceArgsFromAdminRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromAdminRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromAdminRecursive2']


class UserIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    referredBy: Union[bool, 'UserArgsFromAdminRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromAdminRecursive3']
    balance: Union[bool, 'BalanceArgsFromAdminRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromAdminRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromAdminRecursive3']


class UserIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    referredBy: Union[bool, 'UserArgsFromAdminRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromAdminRecursive4']
    balance: Union[bool, 'BalanceArgsFromAdminRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromAdminRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromAdminRecursive4']


class UserIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class UserArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyUserArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive1']


class BalanceIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive2']


class BalanceIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive3']


class BalanceIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive4']


class BalanceIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class BalanceArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyBalanceArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive1']


class TransactionIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive2']


class TransactionIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive3']


class TransactionIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive4']


class TransactionIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class TransactionArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyTransactionArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive1']


class DepositIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive2']


class DepositIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive3']


class DepositIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive4']


class DepositIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class DepositArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyDepositArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive1']


class WithdrawalIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive2']


class WithdrawalIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive3']


class WithdrawalIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromAdminRecursive4']


class WithdrawalIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class WithdrawalArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyWithdrawalArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive1']


class CryptoOrderIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive2']


class CryptoOrderIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive3']


class CryptoOrderIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    user: Union[bool, 'UserArgsFromAdminRecursive4']


class CryptoOrderIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class CryptoOrderArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyCryptoOrderArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class SettingIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""


class SettingIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""


class SettingIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""


class SettingIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class SettingArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManySettingArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class CoinSettingIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""


class CoinSettingIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""


class CoinSettingIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""


class CoinSettingIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class CoinSettingArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyCoinSettingArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class PaymentMethodIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""


class PaymentMethodIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""


class PaymentMethodIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""


class PaymentMethodIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class PaymentMethodArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyPaymentMethodArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive1']


class AdminIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive2']


class AdminIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive3']


class AdminIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromAdminRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromAdminRecursive4']


class AdminIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class AdminArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyAdminArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromAdmin(TypedDict, total=False):
    """Relational arguments for Admin"""


class ReferralSettingIncludeFromAdminRecursive1(TypedDict, total=False):
    """Relational arguments for Admin"""


class ReferralSettingIncludeFromAdminRecursive2(TypedDict, total=False):
    """Relational arguments for Admin"""


class ReferralSettingIncludeFromAdminRecursive3(TypedDict, total=False):
    """Relational arguments for Admin"""


class ReferralSettingIncludeFromAdminRecursive4(TypedDict, total=False):
    """Relational arguments for Admin"""

    

class ReferralSettingArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    
    

class FindManyReferralSettingArgsFromAdmin(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromAdminRecursive1(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromAdminRecursive2(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromAdminRecursive3(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromAdminRecursive4(TypedDict, total=False):
    """Arguments for Admin"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyAdminArgs = FindManyAdminArgsFromAdmin
FindFirstAdminArgs = FindManyAdminArgsFromAdmin


    

class AdminWhereInput(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    passwordHash: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    approvedDeposits: 'DepositListRelationFilter'
    approvedWithdrawals: 'WithdrawalListRelationFilter'

    # should be noted that AND and NOT should be Union['AdminWhereInputRecursive1', List['AdminWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['AdminWhereInputRecursive1']
    OR: List['AdminWhereInputRecursive1']
    NOT: List['AdminWhereInputRecursive1']


class AdminWhereInputRecursive1(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    passwordHash: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    approvedDeposits: 'DepositListRelationFilter'
    approvedWithdrawals: 'WithdrawalListRelationFilter'

    # should be noted that AND and NOT should be Union['AdminWhereInputRecursive2', List['AdminWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['AdminWhereInputRecursive2']
    OR: List['AdminWhereInputRecursive2']
    NOT: List['AdminWhereInputRecursive2']


class AdminWhereInputRecursive2(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    passwordHash: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    approvedDeposits: 'DepositListRelationFilter'
    approvedWithdrawals: 'WithdrawalListRelationFilter'

    # should be noted that AND and NOT should be Union['AdminWhereInputRecursive3', List['AdminWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['AdminWhereInputRecursive3']
    OR: List['AdminWhereInputRecursive3']
    NOT: List['AdminWhereInputRecursive3']


class AdminWhereInputRecursive3(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    passwordHash: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    approvedDeposits: 'DepositListRelationFilter'
    approvedWithdrawals: 'WithdrawalListRelationFilter'

    # should be noted that AND and NOT should be Union['AdminWhereInputRecursive4', List['AdminWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['AdminWhereInputRecursive4']
    OR: List['AdminWhereInputRecursive4']
    NOT: List['AdminWhereInputRecursive4']


class AdminWhereInputRecursive4(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    username: Union[_str, 'types.StringFilter']
    passwordHash: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    approvedDeposits: 'DepositListRelationFilter'
    approvedWithdrawals: 'WithdrawalListRelationFilter'



# aggregate Admin types


    

class AdminScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    passwordHash: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AdminScalarWhereWithAggregatesInputRecursive1']
    OR: List['AdminScalarWhereWithAggregatesInputRecursive1']
    NOT: List['AdminScalarWhereWithAggregatesInputRecursive1']


class AdminScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    passwordHash: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AdminScalarWhereWithAggregatesInputRecursive2']
    OR: List['AdminScalarWhereWithAggregatesInputRecursive2']
    NOT: List['AdminScalarWhereWithAggregatesInputRecursive2']


class AdminScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    passwordHash: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AdminScalarWhereWithAggregatesInputRecursive3']
    OR: List['AdminScalarWhereWithAggregatesInputRecursive3']
    NOT: List['AdminScalarWhereWithAggregatesInputRecursive3']


class AdminScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    passwordHash: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AdminScalarWhereWithAggregatesInputRecursive4']
    OR: List['AdminScalarWhereWithAggregatesInputRecursive4']
    NOT: List['AdminScalarWhereWithAggregatesInputRecursive4']


class AdminScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Admin arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    username: Union[_str, 'types.StringWithAggregatesFilter']
    passwordHash: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class AdminGroupByOutput(TypedDict, total=False):
    id: _str
    username: _str
    passwordHash: _str
    name: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'AdminSumAggregateOutput'
    _avg: 'AdminAvgAggregateOutput'
    _min: 'AdminMinAggregateOutput'
    _max: 'AdminMaxAggregateOutput'
    _count: 'AdminCountAggregateOutput'


class AdminAvgAggregateOutput(TypedDict, total=False):
    """Admin output for aggregating averages"""


class AdminSumAggregateOutput(TypedDict, total=False):
    """Admin output for aggregating sums"""


class AdminScalarAggregateOutput(TypedDict, total=False):
    """Admin output including scalar fields"""
    id: _str
    username: _str
    passwordHash: _str
    name: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


AdminMinAggregateOutput = AdminScalarAggregateOutput
AdminMaxAggregateOutput = AdminScalarAggregateOutput


class AdminMaxAggregateInput(TypedDict, total=False):
    """Admin input for aggregating by max"""
    id: bool
    username: bool
    passwordHash: bool
    name: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class AdminMinAggregateInput(TypedDict, total=False):
    """Admin input for aggregating by min"""
    id: bool
    username: bool
    passwordHash: bool
    name: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class AdminNumberAggregateInput(TypedDict, total=False):
    """Admin input for aggregating numbers"""


AdminAvgAggregateInput = AdminNumberAggregateInput
AdminSumAggregateInput = AdminNumberAggregateInput


AdminCountAggregateInput = TypedDict(
    'AdminCountAggregateInput',
    {
        'id': bool,
        'username': bool,
        'passwordHash': bool,
        'name': bool,
        'isActive': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

AdminCountAggregateOutput = TypedDict(
    'AdminCountAggregateOutput',
    {
        'id': int,
        'username': int,
        'passwordHash': int,
        'name': int,
        'isActive': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


AdminKeys = Literal[
    'id',
    'username',
    'passwordHash',
    'name',
    'isActive',
    'createdAt',
    'updatedAt',
    'approvedDeposits',
    'approvedWithdrawals',
]
AdminScalarFieldKeys = Literal[
    'id',
    'username',
    'passwordHash',
    'name',
    'isActive',
    'createdAt',
    'updatedAt',
]
AdminScalarFieldKeysT = TypeVar('AdminScalarFieldKeysT', bound=AdminScalarFieldKeys)

AdminRelationalFieldKeys = Literal[
        'approvedDeposits',
        'approvedWithdrawals',
    ]

# ReferralSetting types

class ReferralSettingOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the ReferralSetting create method"""
    id: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReferralSettingCreateInput(ReferralSettingOptionalCreateInput):
    """Required arguments to the ReferralSetting create method"""
    referrerBonus: decimal.Decimal
    refereeBonus: decimal.Decimal


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ReferralSettingOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the ReferralSetting create method, without relations"""
    id: _str
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReferralSettingCreateWithoutRelationsInput(ReferralSettingOptionalCreateWithoutRelationsInput):
    """Required arguments to the ReferralSetting create method, without relations"""
    referrerBonus: decimal.Decimal
    refereeBonus: decimal.Decimal

class ReferralSettingConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ReferralSettingCreateWithoutRelationsInput'
    where: 'ReferralSettingWhereUniqueInput'

class ReferralSettingCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ReferralSettingCreateWithoutRelationsInput'
    connect: 'ReferralSettingWhereUniqueInput'
    connect_or_create: 'ReferralSettingConnectOrCreateWithoutRelationsInput'


class ReferralSettingCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ReferralSettingCreateWithoutRelationsInput', List['ReferralSettingCreateWithoutRelationsInput']]
    connect: Union['ReferralSettingWhereUniqueInput', List['ReferralSettingWhereUniqueInput']]
    connect_or_create: Union['ReferralSettingConnectOrCreateWithoutRelationsInput', List['ReferralSettingConnectOrCreateWithoutRelationsInput']]

_ReferralSettingWhereUnique_id_Input = TypedDict(
    '_ReferralSettingWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ReferralSettingWhereUniqueInput = _ReferralSettingWhereUnique_id_Input


class ReferralSettingUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    referrerBonus: decimal.Decimal
    refereeBonus: decimal.Decimal
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReferralSettingUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    referrerBonus: decimal.Decimal
    refereeBonus: decimal.Decimal
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


class ReferralSettingUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ReferralSettingCreateWithoutRelationsInput']
    connect: List['ReferralSettingWhereUniqueInput']
    connect_or_create: List['ReferralSettingConnectOrCreateWithoutRelationsInput']
    set: List['ReferralSettingWhereUniqueInput']
    disconnect: List['ReferralSettingWhereUniqueInput']
    delete: List['ReferralSettingWhereUniqueInput']

    # TODO
    # update: List['ReferralSettingUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ReferralSettingUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ReferralSettingScalarWhereInput']
    # upsert: List['ReferralSettingUpserteWithWhereUniqueWithoutRelationsInput']


class ReferralSettingUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ReferralSettingCreateWithoutRelationsInput'
    connect: 'ReferralSettingWhereUniqueInput'
    connect_or_create: 'ReferralSettingConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ReferralSettingUpdateInput'
    # upsert: 'ReferralSettingUpsertWithoutRelationsInput'


class ReferralSettingUpsertInput(TypedDict):
    create: 'ReferralSettingCreateInput'
    update: 'ReferralSettingUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_ReferralSetting_id_OrderByInput = TypedDict(
    '_ReferralSetting_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_ReferralSetting_referrerBonus_OrderByInput = TypedDict(
    '_ReferralSetting_referrerBonus_OrderByInput',
    {
        'referrerBonus': 'SortOrder',
    },
    total=True
)

_ReferralSetting_refereeBonus_OrderByInput = TypedDict(
    '_ReferralSetting_refereeBonus_OrderByInput',
    {
        'refereeBonus': 'SortOrder',
    },
    total=True
)

_ReferralSetting_isActive_OrderByInput = TypedDict(
    '_ReferralSetting_isActive_OrderByInput',
    {
        'isActive': 'SortOrder',
    },
    total=True
)

_ReferralSetting_createdAt_OrderByInput = TypedDict(
    '_ReferralSetting_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_ReferralSetting_updatedAt_OrderByInput = TypedDict(
    '_ReferralSetting_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_ReferralSetting_RelevanceInner = TypedDict(
    '_ReferralSetting_RelevanceInner',
    {
        'fields': 'List[ReferralSettingScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_ReferralSetting_RelevanceOrderByInput = TypedDict(
    '_ReferralSetting_RelevanceOrderByInput',
    {
        '_relevance': '_ReferralSetting_RelevanceInner',
    },
    total=True
)

ReferralSettingOrderByInput = Union[
    '_ReferralSetting_id_OrderByInput',
    '_ReferralSetting_referrerBonus_OrderByInput',
    '_ReferralSetting_refereeBonus_OrderByInput',
    '_ReferralSetting_isActive_OrderByInput',
    '_ReferralSetting_createdAt_OrderByInput',
    '_ReferralSetting_updatedAt_OrderByInput',
    '_ReferralSetting_RelevanceOrderByInput',
]



# recursive ReferralSetting types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

ReferralSettingRelationFilter = TypedDict(
    'ReferralSettingRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class ReferralSettingListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class ReferralSettingInclude(TypedDict, total=False):
    """ReferralSetting relational arguments"""


    

class UserIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    referredBy: Union[bool, 'UserArgsFromReferralSettingRecursive1']
    referrals: Union[bool, 'FindManyUserArgsFromReferralSettingRecursive1']
    balance: Union[bool, 'BalanceArgsFromReferralSettingRecursive1']
    transactions: Union[bool, 'FindManyTransactionArgsFromReferralSettingRecursive1']
    deposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive1']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive1']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromReferralSettingRecursive1']


class UserIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    referredBy: Union[bool, 'UserArgsFromReferralSettingRecursive2']
    referrals: Union[bool, 'FindManyUserArgsFromReferralSettingRecursive2']
    balance: Union[bool, 'BalanceArgsFromReferralSettingRecursive2']
    transactions: Union[bool, 'FindManyTransactionArgsFromReferralSettingRecursive2']
    deposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive2']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive2']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromReferralSettingRecursive2']


class UserIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    referredBy: Union[bool, 'UserArgsFromReferralSettingRecursive3']
    referrals: Union[bool, 'FindManyUserArgsFromReferralSettingRecursive3']
    balance: Union[bool, 'BalanceArgsFromReferralSettingRecursive3']
    transactions: Union[bool, 'FindManyTransactionArgsFromReferralSettingRecursive3']
    deposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive3']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive3']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromReferralSettingRecursive3']


class UserIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    referredBy: Union[bool, 'UserArgsFromReferralSettingRecursive4']
    referrals: Union[bool, 'FindManyUserArgsFromReferralSettingRecursive4']
    balance: Union[bool, 'BalanceArgsFromReferralSettingRecursive4']
    transactions: Union[bool, 'FindManyTransactionArgsFromReferralSettingRecursive4']
    deposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive4']
    withdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive4']
    cryptoOrders: Union[bool, 'FindManyCryptoOrderArgsFromReferralSettingRecursive4']


class UserIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class UserArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'UserIncludeFromUserRecursive1'


class UserArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'UserIncludeFromUserRecursive2'


class UserArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'UserIncludeFromUserRecursive3'


class UserArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'UserIncludeFromUserRecursive4'


class UserArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyUserArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive1'


class FindManyUserArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive2'


class FindManyUserArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive3'


class FindManyUserArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUserRecursive4'


class FindManyUserArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    
    

class BalanceIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive1']


class BalanceIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive2']


class BalanceIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive3']


class BalanceIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive4']


class BalanceIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class BalanceArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'BalanceIncludeFromBalanceRecursive1'


class BalanceArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'BalanceIncludeFromBalanceRecursive2'


class BalanceArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'BalanceIncludeFromBalanceRecursive3'


class BalanceArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'BalanceIncludeFromBalanceRecursive4'


class BalanceArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyBalanceArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive1'


class FindManyBalanceArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive2'


class FindManyBalanceArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive3'


class FindManyBalanceArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    include: 'BalanceIncludeFromBalanceRecursive4'


class FindManyBalanceArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['BalanceOrderByInput', List['BalanceOrderByInput']]
    where: 'BalanceWhereInput'
    cursor: 'BalanceWhereUniqueInput'
    distinct: List['BalanceScalarFieldKeys']
    
    

class TransactionIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive1']


class TransactionIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive2']


class TransactionIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive3']


class TransactionIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive4']


class TransactionIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class TransactionArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'TransactionIncludeFromTransactionRecursive1'


class TransactionArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'TransactionIncludeFromTransactionRecursive2'


class TransactionArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'TransactionIncludeFromTransactionRecursive3'


class TransactionArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'TransactionIncludeFromTransactionRecursive4'


class TransactionArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyTransactionArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive1'


class FindManyTransactionArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive2'


class FindManyTransactionArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive3'


class FindManyTransactionArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    include: 'TransactionIncludeFromTransactionRecursive4'


class FindManyTransactionArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['TransactionOrderByInput', List['TransactionOrderByInput']]
    where: 'TransactionWhereInput'
    cursor: 'TransactionWhereUniqueInput'
    distinct: List['TransactionScalarFieldKeys']
    
    

class DepositIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive1']


class DepositIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive2']


class DepositIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive3']


class DepositIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive4']


class DepositIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class DepositArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'DepositIncludeFromDepositRecursive1'


class DepositArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'DepositIncludeFromDepositRecursive2'


class DepositArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'DepositIncludeFromDepositRecursive3'


class DepositArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'DepositIncludeFromDepositRecursive4'


class DepositArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyDepositArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive1'


class FindManyDepositArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive2'


class FindManyDepositArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive3'


class FindManyDepositArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    include: 'DepositIncludeFromDepositRecursive4'


class FindManyDepositArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['DepositOrderByInput', List['DepositOrderByInput']]
    where: 'DepositWhereInput'
    cursor: 'DepositWhereUniqueInput'
    distinct: List['DepositScalarFieldKeys']
    
    

class WithdrawalIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive1']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive1']


class WithdrawalIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive2']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive2']


class WithdrawalIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive3']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive3']


class WithdrawalIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive4']
    approvedBy: Union[bool, 'AdminArgsFromReferralSettingRecursive4']


class WithdrawalIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class WithdrawalArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class WithdrawalArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class WithdrawalArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class WithdrawalArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class WithdrawalArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyWithdrawalArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive1'


class FindManyWithdrawalArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive2'


class FindManyWithdrawalArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive3'


class FindManyWithdrawalArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    include: 'WithdrawalIncludeFromWithdrawalRecursive4'


class FindManyWithdrawalArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['WithdrawalOrderByInput', List['WithdrawalOrderByInput']]
    where: 'WithdrawalWhereInput'
    cursor: 'WithdrawalWhereUniqueInput'
    distinct: List['WithdrawalScalarFieldKeys']
    
    

class CryptoOrderIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive1']


class CryptoOrderIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive2']


class CryptoOrderIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive3']


class CryptoOrderIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    user: Union[bool, 'UserArgsFromReferralSettingRecursive4']


class CryptoOrderIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class CryptoOrderArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class CryptoOrderArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class CryptoOrderArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class CryptoOrderArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class CryptoOrderArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyCryptoOrderArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive1'


class FindManyCryptoOrderArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive2'


class FindManyCryptoOrderArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive3'


class FindManyCryptoOrderArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    include: 'CryptoOrderIncludeFromCryptoOrderRecursive4'


class FindManyCryptoOrderArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CryptoOrderOrderByInput', List['CryptoOrderOrderByInput']]
    where: 'CryptoOrderWhereInput'
    cursor: 'CryptoOrderWhereUniqueInput'
    distinct: List['CryptoOrderScalarFieldKeys']
    
    

class SettingIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class SettingIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class SettingIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class SettingIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class SettingIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class SettingArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'SettingIncludeFromSettingRecursive1'


class SettingArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'SettingIncludeFromSettingRecursive2'


class SettingArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'SettingIncludeFromSettingRecursive3'


class SettingArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'SettingIncludeFromSettingRecursive4'


class SettingArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManySettingArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive1'


class FindManySettingArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive2'


class FindManySettingArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive3'


class FindManySettingArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    include: 'SettingIncludeFromSettingRecursive4'


class FindManySettingArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['SettingOrderByInput', List['SettingOrderByInput']]
    where: 'SettingWhereInput'
    cursor: 'SettingWhereUniqueInput'
    distinct: List['SettingScalarFieldKeys']
    
    

class CoinSettingIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class CoinSettingIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class CoinSettingIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class CoinSettingIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class CoinSettingIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class CoinSettingArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class CoinSettingArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class CoinSettingArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class CoinSettingArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class CoinSettingArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyCoinSettingArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive1'


class FindManyCoinSettingArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive2'


class FindManyCoinSettingArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive3'


class FindManyCoinSettingArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    include: 'CoinSettingIncludeFromCoinSettingRecursive4'


class FindManyCoinSettingArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['CoinSettingOrderByInput', List['CoinSettingOrderByInput']]
    where: 'CoinSettingWhereInput'
    cursor: 'CoinSettingWhereUniqueInput'
    distinct: List['CoinSettingScalarFieldKeys']
    
    

class PaymentMethodIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class PaymentMethodIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class PaymentMethodIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class PaymentMethodIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class PaymentMethodIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class PaymentMethodArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class PaymentMethodArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class PaymentMethodArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class PaymentMethodArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class PaymentMethodArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyPaymentMethodArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive1'


class FindManyPaymentMethodArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive2'


class FindManyPaymentMethodArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive3'


class FindManyPaymentMethodArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    include: 'PaymentMethodIncludeFromPaymentMethodRecursive4'


class FindManyPaymentMethodArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['PaymentMethodOrderByInput', List['PaymentMethodOrderByInput']]
    where: 'PaymentMethodWhereInput'
    cursor: 'PaymentMethodWhereUniqueInput'
    distinct: List['PaymentMethodScalarFieldKeys']
    
    

class AdminIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive1']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive1']


class AdminIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive2']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive2']


class AdminIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive3']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive3']


class AdminIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""
    approvedDeposits: Union[bool, 'FindManyDepositArgsFromReferralSettingRecursive4']
    approvedWithdrawals: Union[bool, 'FindManyWithdrawalArgsFromReferralSettingRecursive4']


class AdminIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class AdminArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'AdminIncludeFromAdminRecursive1'


class AdminArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'AdminIncludeFromAdminRecursive2'


class AdminArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'AdminIncludeFromAdminRecursive3'


class AdminArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'AdminIncludeFromAdminRecursive4'


class AdminArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyAdminArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive1'


class FindManyAdminArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive2'


class FindManyAdminArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive3'


class FindManyAdminArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    include: 'AdminIncludeFromAdminRecursive4'


class FindManyAdminArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['AdminOrderByInput', List['AdminOrderByInput']]
    where: 'AdminWhereInput'
    cursor: 'AdminWhereUniqueInput'
    distinct: List['AdminScalarFieldKeys']
    
    

class ReferralSettingIncludeFromReferralSetting(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class ReferralSettingIncludeFromReferralSettingRecursive1(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class ReferralSettingIncludeFromReferralSettingRecursive2(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class ReferralSettingIncludeFromReferralSettingRecursive3(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""


class ReferralSettingIncludeFromReferralSettingRecursive4(TypedDict, total=False):
    """Relational arguments for ReferralSetting"""

    

class ReferralSettingArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class ReferralSettingArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class ReferralSettingArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class ReferralSettingArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class ReferralSettingArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    
    

class FindManyReferralSettingArgsFromReferralSetting(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive1'


class FindManyReferralSettingArgsFromReferralSettingRecursive1(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive2'


class FindManyReferralSettingArgsFromReferralSettingRecursive2(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive3'


class FindManyReferralSettingArgsFromReferralSettingRecursive3(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    include: 'ReferralSettingIncludeFromReferralSettingRecursive4'


class FindManyReferralSettingArgsFromReferralSettingRecursive4(TypedDict, total=False):
    """Arguments for ReferralSetting"""
    take: int
    skip: int
    order_by: Union['ReferralSettingOrderByInput', List['ReferralSettingOrderByInput']]
    where: 'ReferralSettingWhereInput'
    cursor: 'ReferralSettingWhereUniqueInput'
    distinct: List['ReferralSettingScalarFieldKeys']
    


FindManyReferralSettingArgs = FindManyReferralSettingArgsFromReferralSetting
FindFirstReferralSettingArgs = FindManyReferralSettingArgsFromReferralSetting


    

class ReferralSettingWhereInput(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ReferralSettingWhereInputRecursive1', List['ReferralSettingWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['ReferralSettingWhereInputRecursive1']
    OR: List['ReferralSettingWhereInputRecursive1']
    NOT: List['ReferralSettingWhereInputRecursive1']


class ReferralSettingWhereInputRecursive1(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ReferralSettingWhereInputRecursive2', List['ReferralSettingWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['ReferralSettingWhereInputRecursive2']
    OR: List['ReferralSettingWhereInputRecursive2']
    NOT: List['ReferralSettingWhereInputRecursive2']


class ReferralSettingWhereInputRecursive2(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ReferralSettingWhereInputRecursive3', List['ReferralSettingWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['ReferralSettingWhereInputRecursive3']
    OR: List['ReferralSettingWhereInputRecursive3']
    NOT: List['ReferralSettingWhereInputRecursive3']


class ReferralSettingWhereInputRecursive3(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ReferralSettingWhereInputRecursive4', List['ReferralSettingWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['ReferralSettingWhereInputRecursive4']
    OR: List['ReferralSettingWhereInputRecursive4']
    NOT: List['ReferralSettingWhereInputRecursive4']


class ReferralSettingWhereInputRecursive4(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalFilter']
    isActive: Union[_bool, 'types.BooleanFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']



# aggregate ReferralSetting types


    

class ReferralSettingScalarWhereWithAggregatesInput(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReferralSettingScalarWhereWithAggregatesInputRecursive1']
    OR: List['ReferralSettingScalarWhereWithAggregatesInputRecursive1']
    NOT: List['ReferralSettingScalarWhereWithAggregatesInputRecursive1']


class ReferralSettingScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReferralSettingScalarWhereWithAggregatesInputRecursive2']
    OR: List['ReferralSettingScalarWhereWithAggregatesInputRecursive2']
    NOT: List['ReferralSettingScalarWhereWithAggregatesInputRecursive2']


class ReferralSettingScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReferralSettingScalarWhereWithAggregatesInputRecursive3']
    OR: List['ReferralSettingScalarWhereWithAggregatesInputRecursive3']
    NOT: List['ReferralSettingScalarWhereWithAggregatesInputRecursive3']


class ReferralSettingScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ReferralSettingScalarWhereWithAggregatesInputRecursive4']
    OR: List['ReferralSettingScalarWhereWithAggregatesInputRecursive4']
    NOT: List['ReferralSettingScalarWhereWithAggregatesInputRecursive4']


class ReferralSettingScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """ReferralSetting arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    referrerBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    refereeBonus: Union[decimal.Decimal, 'types.DecimalWithAggregatesFilter']
    isActive: Union[_bool, 'types.BooleanWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class ReferralSettingGroupByOutput(TypedDict, total=False):
    id: _str
    referrerBonus: decimal.Decimal
    refereeBonus: decimal.Decimal
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    _sum: 'ReferralSettingSumAggregateOutput'
    _avg: 'ReferralSettingAvgAggregateOutput'
    _min: 'ReferralSettingMinAggregateOutput'
    _max: 'ReferralSettingMaxAggregateOutput'
    _count: 'ReferralSettingCountAggregateOutput'


class ReferralSettingAvgAggregateOutput(TypedDict, total=False):
    """ReferralSetting output for aggregating averages"""


class ReferralSettingSumAggregateOutput(TypedDict, total=False):
    """ReferralSetting output for aggregating sums"""


class ReferralSettingScalarAggregateOutput(TypedDict, total=False):
    """ReferralSetting output including scalar fields"""
    id: _str
    referrerBonus: decimal.Decimal
    refereeBonus: decimal.Decimal
    isActive: _bool
    createdAt: datetime.datetime
    updatedAt: datetime.datetime


ReferralSettingMinAggregateOutput = ReferralSettingScalarAggregateOutput
ReferralSettingMaxAggregateOutput = ReferralSettingScalarAggregateOutput


class ReferralSettingMaxAggregateInput(TypedDict, total=False):
    """ReferralSetting input for aggregating by max"""
    id: bool
    referrerBonus: bool
    refereeBonus: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class ReferralSettingMinAggregateInput(TypedDict, total=False):
    """ReferralSetting input for aggregating by min"""
    id: bool
    referrerBonus: bool
    refereeBonus: bool
    isActive: bool
    createdAt: bool
    updatedAt: bool


class ReferralSettingNumberAggregateInput(TypedDict, total=False):
    """ReferralSetting input for aggregating numbers"""


ReferralSettingAvgAggregateInput = ReferralSettingNumberAggregateInput
ReferralSettingSumAggregateInput = ReferralSettingNumberAggregateInput


ReferralSettingCountAggregateInput = TypedDict(
    'ReferralSettingCountAggregateInput',
    {
        'id': bool,
        'referrerBonus': bool,
        'refereeBonus': bool,
        'isActive': bool,
        'createdAt': bool,
        'updatedAt': bool,
        '_all': bool,
    },
    total=False,
)

ReferralSettingCountAggregateOutput = TypedDict(
    'ReferralSettingCountAggregateOutput',
    {
        'id': int,
        'referrerBonus': int,
        'refereeBonus': int,
        'isActive': int,
        'createdAt': int,
        'updatedAt': int,
        '_all': int,
    },
    total=False,
)


ReferralSettingKeys = Literal[
    'id',
    'referrerBonus',
    'refereeBonus',
    'isActive',
    'createdAt',
    'updatedAt',
]
ReferralSettingScalarFieldKeys = Literal[
    'id',
    'referrerBonus',
    'refereeBonus',
    'isActive',
    'createdAt',
    'updatedAt',
]
ReferralSettingScalarFieldKeysT = TypeVar('ReferralSettingScalarFieldKeysT', bound=ReferralSettingScalarFieldKeys)

ReferralSettingRelationalFieldKeys = _NoneType



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields